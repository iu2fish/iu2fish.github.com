var store = [{
        "title": "最近的生活状态",
        "excerpt":"不知不觉的来上海4个月了。从苏州来到上海，加入携程之后，一直在忙，这里的忙是相对于之前，忙于自己喜欢的事情，每天醒来都感觉满满的正能量，因为可以去做自己喜欢的事情，工作压力不是太大，虽然说，魔都的生活工作节奏很快，但是在这4个月之中，感觉并不是特别快。所以，只有体验过才是自己的，别人说，北上广怎么怎么样，节奏快啊，如此云云，那终究是别人而不是自己。说实话，上海的人真多，交通真的是拥挤，记得入职第一天的时候，我还发了一条推特说，有想过上海的交通拥挤，但是没想到如此拥挤。以前在苏州的时候，公交不是\t太拥挤，遇到人多的时候，我就会等下一班，结果在上海的第一天，我遇到人很多，我就等下一班，结果，下一班还是那么多人，再等下一班还是那么多人，后来学乖了，只要能上去，就上去吧~来到携程之后，这边很有技术氛围，每周都有技术分享，大家都能在一起讨论学习新的技术，领导的态度就是，happy coding。有次开会，领导说，希望大家能够开心的工作，遇到不开心的事，或者工作不爽了，要说出来。不要让自己痛苦的不行，自己憋在心里不说。如果我们的同事，被别人挖走，如果是高薪挖走，那我们没办法，咱们给不起那么多，如果是离开上海，回家乡或者去一个房价相对较低的城市，我们也没办法，谁让上海的房价那么高，很多人买不起房呢，第三种就是，因为工作不开心被别人挖走了，那就是领导的责任了。 ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2014/10/18/%E6%9C%80%E8%BF%91%E7%9A%84%E7%94%9F%E6%B4%BB%E7%8A%B6%E6%80%81.html"
      },{
        "title": "Javascript中不引入第三方变量交换a和b的值",
        "excerpt":"在上一家公司面试的时候，面试官出了一个问题，如何不引入第三方变量交换a和b的值。当时的回答并不好，后来回去研究了下，发现还是蛮好玩的.1.最省字节法 a = [b, b = a][0]2.数值型可用 a = a + b; b = a - b; a = a - b; 3.恶搞法1 a = {a: b, b: b = a}4.恶搞法2 a = a * b; b = a / b; a = a / b;5.其他方法 a = [b][b =...","categories": ["前端"],
        "tags": ["javascript"],
        "url": "http://localhost:4000/%E5%89%8D%E7%AB%AF/2014/10/19/Javascript%E4%B8%AD%E4%B8%8D%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2a%E5%92%8Cb%E7%9A%84%E5%80%BC.html"
      },{
        "title": "最近的一些想法",
        "excerpt":"最近一直都想写篇关于这段时间的一些想法与思考，可是都没有来的及落笔。正好昨天去杭州参加了阿里的D2技术论坛，见了一些基友，交流了一些想法，触动蛮大的。所以趁热写一下最近的一些想法吧，不然过一段时间，又忘了。 首先说说，这段时间的工作状态吧，三期这个项目做完，我接下来也就比较轻松了，可以自己搞自己的技术，往自己感兴趣的方向发展吧。通过这个项目也认识到自己很多不足，最根本的就是自己的javascript能力。而我感兴趣的也是javascript这个方向。javascript相对于css，html可以玩的比较多，通过这次d2也可以发现，好像这次的d2就没有css的相关内容，记得之前玉伯说过，无论你承不承认，现在的社会不需要太多的html技术专家。无论是6月的杭js，还是这次的D2，都说到了nodejs，虽然争议很大，但是很是有很多地方可以尝试的。组里，接下来也准备使用nodejs做开发，可以先尝试下，做些小工具，以提高工作效率。本来希望是做完三期之后，开始转h5得，好像暂时还不能接触h5的相关的一些任务，不过没关系，正好趁这段时间，好好地充充电，弥补自己javascript功底差得短板。只有把javascript玩熟了，才能走得更远。 在今年的D2上认识了一群基友，见到了群主@情封，认识了瑶姐，五花肉，神仙，鬼懿，等等一大波人，五花肉真的是不一般，还要感谢神仙的星巴克，酒会开始之后，我们几个就去西溪湿地夜游去了。次日，又去了@灵隐寺，值得说的是，杭州的很多地方空气真的很好，天然氧吧。 接下来的计划是，闭关修炼自己的javascript大法。元旦出关，看看自己的进步如何。每天写一篇看书笔记，把自己所看的，还有自己的理解，写一篇博文，通过github提交，这样也比较直观。每天Coding&amp;Reading Plan 无论是 code还是read 都必须要提交github。 ","categories": ["随笔"],
        "tags": ["D2","css","javascript","node"],
        "url": "http://localhost:4000/%E9%9A%8F%E7%AC%94/2014/10/27/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95.html"
      },{
        "title": "javascript 对象",
        "excerpt":"在javascript中对象为“王”：javascript里几乎所有的东西都是对象或者用起来像对象。理解了对象，就能够理解javascript，因此说下javascript的对象。 var cody = new Object();cody.living = true;cody.gender = 'male';最重要的是要记住：对象只是属性的容器，每个属性都有一个名称和一个值。javascript中采用具有命名值属性的容器这一概念作为javascript中表达式的构建块。cody对象是一个值，通过创建对象将这个值表示为javascript对象，给对象命名，然后将属性赋值给对象。 ","categories": [],
        "tags": ["javascript"],
        "url": "http://localhost:4000/2014/10/28/javascript-%E5%AF%B9%E8%B1%A1.html"
      },{
        "title": "我的2014D2之旅",
        "excerpt":"上个周末第一次参加阿里的D2，因为第一次很期待D2 亦或许是ADC，或许是今年的杭JS的缘故，今年的D2延迟到了10月份，记得以前D2都是7月份举办的。记得之前还在知乎上问过，今年D2的举办时间，不过没有得到确定的答案，直到今年的十一之前，才打开报名通道，不得不吐槽下，今年的报名方式，实在是不人性化，不过也好，刷了一部分不会使用git的童鞋，程序员竟然不会使用git，肯定会被鄙视的。由于在上海，又不想多花钱多住一晚酒店，所以就25号早上，起了个早乘动车去杭州了。在火车站遇到了鞋厂的@薛梦飞，还有之前约好的@周文彬，文彬这家伙，不知不觉的被@sofish挖到饿了么，害我还去文彬之前的工位，商量一起去D2的事宜，去了他原来的工位才知道，他已经离职了，直到真相后，一股蛋蛋的忧桑。扯远了，还是继续D2吧。在动车上一觉醒来，已经到达杭州了。我们三个商量下，还是打车去阿里西溪园区，发现杭州还真是堵的不行，周六那么早在高架上竟然堵得一塌糊涂。师傅说，平常都不堵得啊，不知道为什么今天这么堵？其实，我在内心说，是不是今天很多程序员来杭州，导致的堵车啊~从东站到园区，折腾了一个多小时，到了园区的门口，工作人员，说，把你的二维码拿出来看看，我就掏出了手机，让他看，顺便说了句，你看看二维码，就知道我的信息了？工作人员说，当然不是了。然后我们就进门了，顺便拍了张阿里的照片。 接着就跟着很多人去签到的地方去了。签了到，就进了会场，由于去的比较晚，只能坐在后面，不一会儿，薛导@点头猪来了，我诧异的问道，你不是昨天就到了吗？怎么也来那么迟，女神答道，就是因为咱们厂的弹性工作制所赐啊，早上醒不来。女神看到@民工精髓V，顺便过去打了个招呼，回来说，你看民工大叔，穿了件咱们厂的T，O(∩_∩)O哈哈~，这样我才知道民工大叔穿了件鞋厂的T。 接下来主持人开始上场了，只能说，主持人的普通话太标准了。介绍了D2历经的风风雨雨，还有今天的成就，如此云云。第一场是，来自百度的同学，分享数据的可视化，感觉蛮好玩的，正好看到前一段时间他们有出的这个报告。中午茶歇时，去了阿里的食堂吃饭，说句良心话，阿里的食堂真的比鞋厂的食堂好吃多了，并且还便宜！期待下，鞋厂搬到soho之后，顺便把食堂的厨师也换了吧。下午第一场分享，是关于nodejs的话题，由于刚吃完饭，加上早上早起，所以困意十足啊。在听完了之后，去了分会场，听了航旅无线H5 的一些话题，反正对H5的开发业蛮感兴趣的，我看同事们在调试debug的时候，蛮痛苦的，就看看他们怎么调试的，结果他们提供的调试debug的方案，和我们现在的很类似，有点失望。在听完这个之后，@情封 大大在群里，邀请大家去星巴克，请大家喝咖啡，于是就和文彬一起出了会场去星巴克，碰巧的是，正好遇到了薛导，薛导说，我也去拜见下群主吧，虽然我在群里都是潜水。到了星巴克，第一次见到了群主@情封，还有@五花肉，@我是神仙，@瑶姐，还有@鬼懿，虽然我在他的群，被T了。于是，五花肉请我们喝咖啡，我是神仙买单，不过没关系，阿里都是土豪。在星巴克聊了好久，五花肉突然来了句，你就是U2啊，于是，内伤了。聊了好久，准备去酒会了，在酒会上遇到了很多大神，虽然大神都不认识我。在酒会没有多久，就被情封拉着说，我们夜游去吧，选来选去，最终去了西溪湿地。先po一张照片吧。一群程序员夜游西溪湿地，想想也是醉了。不过西溪湿地确实很赞，适合和妹子一起去玩，也适合当地人吃完晚饭散散步，消消食。几个人，谈天谈地，说了好多，从西溪湿地出来后，就去酒店了。酒店是在去哪儿订的。之所以在去哪儿订，是因为要比鞋厂便宜20块钱，结果，就因为这个，还麻烦了下。到了酒店前台，报了名字，办理入职手续，告诉我，价格和我之前预定的时候不一样，我说，预定的时一个价格啊，怎么变了呢，前台告诉我，去哪儿把我的订单取消了，所以，你只能按原价入住了。无奈，只能如此了。到了房间，我投诉了，去哪儿，一会儿，去哪儿的客服打电话过来说，涨价是怎么回事，我就如实的告诉她，客服说，她联系酒店前台问问。一会儿又打过来说，她们没有按去哪儿订的手续入住，并且你也入住了，那没有办法了。所以觉得很坑，不仅仅是去哪儿，估计鞋厂有时也会这样，你订了，但是酒店算你没有订的价格入住，在外地就是不好，容易被人忽悠。第二天，我们几个人去了灵隐寺，杭州的绿化真的很好，灵隐寺飞来峰的空气真的很赞。一行人，玩了将近到了12点，我和文彬，去了火车站，情封他们继续灵隐寺之行。我就返沪了。两天的D2之行，在会场上学到的并不多，私下通过大家的聊天，才知道，原来大家都在玩这个啊，不会脱离大家太远。反正每次的交流会大家都是吹吹牛逼，见见基友，其实这就够了，学习还是靠自己，知道人家在弄什么就行了。总之，这次D2之行，学到了不少，也玩到了不少，值得。 ","categories": [],
        "tags": ["D2"],
        "url": "http://localhost:4000/2014/10/29/%E6%88%91%E7%9A%842014D2%E4%B9%8B%E6%97%85.html"
      },{
        "title": "Gulp的简单配置",
        "excerpt":"###第一步安装node###首先，也是最基本的，我们需要搭建node环境。访问nodejs.org，然后点击大大的install按钮，就可以下载安装了。###第二步安装Gulp###在安装node之后，我们开始使用命令行安装Gulp，在命令行总输入 sudo npm install -g gulp1. sodo 是以管理员的身份执行命令，一般会要求输入电脑密码。2. npm 是安装node模块的工具，执行install命令3. -g 表示在全局环境安装，以便任何项目都能使用它4. 最后Gulp是将要安装的node模块的名字运行时注意查看命令行是否有出错的信息，安装完成后，你可以使用下面的命令查看gulp的版本号以确保gulp已经被正确安装 gulp -v接下来，我们需要将gulp安装到项目本地 npm install gulp --save-devps:如果失败，尝试下前面加上 sudo,这里我们使用--save-dev来更新package.json文件，更新devDependencies值，以表明项目需要依赖gulp.###第三步新建Gulpfile文件，运行Gulp### 安装好Gulp之后我们需要告诉它要为我们执行哪些任务，首先我们要清楚的知道项目需要哪些任务，自己都不清楚，代码怎么会知道呢，不要像PM一样，自己都不知道项目要做哪些功能. 检查Javascript编译sass或者less之类的预处理文件合并javascript压缩并重命名合并后的javascript####安装依赖#### npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename --save-dev 提醒下，如果以上命令提示权限错误，需要加上sudo再次尝试 ####新建gulpfile文件#### 现在组件都安装完毕，我们需要新建gulpfile文件以指定gulp需要为我们完成什么任务。 gulp只有5个方法：task,run,watch,src和dest,在项目根目录新建一个js文件并命名为gulpfile.js把下面的代码贴进去: // 引入 gulpvar gulp = require('gulp'); // 引入组件var jshint = require('gulp-jshint');var sass = require('gulp-sass');var concat =...","categories": [],
        "tags": ["javascript","Gulp"],
        "url": "http://localhost:4000/2014/10/30/Gulp%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE.html"
      },{
        "title": "在iPad 上click事件无效",
        "excerpt":"今天测试提了一个bug，在ipad上的click事件无效，要两次click才可以，查了下资料，发现要兼容下，才可以。 $('.documeng').on('click touchstart',function (e) {\t//do something});这样才可以。 解决方案来自：stackoverflow ","categories": [],
        "tags": ["javascript","bug","ipad","click","touchstart"],
        "url": "http://localhost:4000/2014/11/04/%E5%9C%A8ipad-%E4%B8%8Aclick%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88.html"
      },{
        "title": "前端工具收藏夹",
        "excerpt":"最近在折腾Gulp，之前也弄过Grunt，所以收集了一些资料，供大家一块研究。##Gulp##Gulp了不起的任务运行器Gulp基础教程Gulp入门教程Gulp.jsGulp.js-LiveReload 自動刷新頁面Gulp思维–Gulp高级技巧 ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2014/11/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E6%94%B6%E8%97%8F%E5%A4%B9.html"
      },{
        "title": "Git 的基本指令",
        "excerpt":"今天看了一篇文章，有Github账号 ≠ Github,正好最近团队也有tfs迁到git了。###Git配置###你可以在.gitconfig文件中，防止git的全局配置，文件位于用户的home目录。####用户信息####通过如下命令来配置用户名和Email git config --global user.name \"Example Surname\"git config --global user.email \"your.email@gmail.com\"Set default so that all changes are always pushed to the repositorygit config --global push.default \"matching\"获取Git配置信息，执行以下命令： git config --list###创建版本库###**什么是版本库呢？版本库又名仓库，英文名为repository，你可以简单理解成一个目录，这个目录里面的文件都被git管理起来，每个文件的修改，删除，git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。所以，创建一个版本库应该非常简单，首先，选择一个合适的地方，创建一个空目录： $ git mrkdir gitdir$ cd gitdir$ pwdpwd命令 ","categories": [],
        "tags": ["git"],
        "url": "http://localhost:4000/2014/11/10/git-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html"
      },{
        "title": "Learning-Backbone-1",
        "excerpt":"今天开始，进行Backbone的学习笔记了。###模型###Backbone模型包含应用程序里地数据以及数据相关的逻辑。例如：可以使用一个模型来表示一个待处理项，它包含了像title和compleated的属性。可以看下面的代码：c var Todo = Backbone.Model.extend({});var todo1 = new Todo();console.log(JSON.stringify(todo1));var todo2 = new Todo({\ttitle:\"Check the attributes of both model instance in console.\",\tcompleated:true});console.log(JSON.stringity(todo2));","categories": [],
        "tags": ["javascript","Backbone"],
        "url": "http://localhost:4000/2015/01/31/Learning-Backbone-1.html"
      },{
        "title": "javascript 错误以及如何修复",
        "excerpt":"原文《[JavaScript Errors and How to Fix Them](http://davidwalsh.name/fix-javascript-errors)》 作者：Jani Hartikainen 翻译：[涂鸦码农](http://weibo.com/newwave) 译文：[译文地址](http://jinlong.github.io/2015/02/01/javascript-errors-and-how-to-fix-them/)JavaScript 调试是一场噩梦：首先给出的错误非常难以理解，其次给出的行号不总有帮助。有个查找错误含义，及修复措施的列表，是不是很有用？以下是奇怪的 JavaScript 错误列表。同样的错误，不同的浏览器会给出不同的消息，因此有一些不同的例子。###如何读懂错误？###首先，让我们快速看下错误信息的结构。理解结构有助于理解错误，如果遇到列表之外的错误会减少麻烦。Chrome 中典型的错误像这样： Uncaught TypeError: undefined is not a function错误的结构如下：1.Uncaught TypeError：这部分信息通常不是很有用。Uncaught 表示错误没有被 catch 语句捕获，TypeError 是错误的名字。2.undefined is not a function: 这部分信息，你必须逐字阅读。比如这里表示代码尝试使用 undefined ，把它当做一个函数。其它基于 webkit 的浏览器，比如 Safari ，给出的错误格式跟 Chrome 很类似。Firefox 也类似，但是不总包含第一部分，最新版本的 IE 也给出比 Chrome 简单的错误 - 但是在这里，简单并不总代表好。以下是真正的错误。####Uncaught TypeError: undefined is...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2015/02/03/javascript-errors-and-how-to-fix-them.html"
      },{
        "title": "Gulp-4.0-update-preview",
        "excerpt":"Gulp 4.0 发布在即，新首页已经上线，新版将会对任务系统做较大的修改，不再兼容3.X及之前版本的任务系统。###新年新气象   新的任务系统(基于bach，替换掉了基于orchestrator 的任务系统)  移除gulp.reset  gulp.task不再支持三个参数的用法  gulp.task用字符串注册的任务必须死直接在命令行中调用的任务  gulp.task可以接受单参数语法，这个必须是一个命名函数，函数名会被作为任务名  添加了gulp.series和gulp.parallel方法用于组合任务  添加了gulp.tree方法用于获取任务树，传入{deep:true}参数可以得到一个archy兼容的节点列表  添加了gulp.registry方法以定制注册表  添加了gulp.symlink方法，功能和gulp.dest一致，不过是以软链接的方式  gulp.dest和gulp.symlink方法添加了dirMode参数允许对目标目录更好地控制  gulp.src接收的文件匹配字符串会顺序解释，所以你可以写成这样 gulp.src(['*.js', '!b*.js', 'bad.js'])（排除所有以 b 开头的 JS 文件但是除了 bad.js）  gulp.src 方法添加了 since 选项，筛选在特定时间点之后修改过的文件（用于增量编译）  将命令行分离出来成为一个独立模块，以便节约带宽/空间。用 npm install gulp -g 或 npm install gulp-cli -g 都可以安装命令行，只是 gulp-cli 不包含模块代码所以比较小  命令行添加了 --tasks-json 参数，可以导出整个任务树以供他用  命令行添加了 --verify 参数用以检查 package.json 中是否包含黑名单插件（违背准则而被禁入官方插件列表的可怜娃们）。","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2015/02/04/Gulp-4-0-update-preview.html"
      },{
        "title": "深入理解javascript原型和闭包1之一切都是对象",
        "excerpt":"####一切都是对象，这句话的重点是如何去理解对象这个概念####当然了也不是所有的都是对象，值类型就不死对象。 首先，咱们还是先看看javascript中一个常用的函数—typeof()。typeof应该算是咱们的老朋友，还有谁没用过它？typeof 函数输出的一共几种类型，在此列出： function show ( x ) { console.log( typeof (x) ); //undefined console.log( typeof ( 10 ) ); //number console.log(typeof ('abc')); //string console.log(typeof (true) ); //Boolean console.log( typeof ( function () {})); //Function console.log(typeof ([1, 'a', true])); //Object console.log(typeof ({'a':10, 'b':20})); //Object console.log(typeof (null)); // Object console.log( tyoeof...","categories": [],
        "tags": ["javascript"],
        "url": "http://localhost:4000/2015/02/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%851%E4%B9%8B%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1.html"
      },{
        "title": "深入理解javascript原型和闭包（2）——函数和对象的关系",
        "excerpt":"上文已经提到，函数就是对象的一种，因为通过instanceof 函数可以判断。 var fn = function () {};console.log(fn instanceof Object);h对！函数是一种对象，但是函数却不像数组一样，你可以说数组是对象的一种，因为数组就是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，这一节就缕一缕。还是先看一个小例子。 function Fn () { this.name = \"iu2fish\", this.year = 1990;}var fn1 = new Fn();上面的这个例子很简单，他能说明，对象可以通过函数来创建。对，也只能说明这一点。但是，我要说—–对象都是通过函数创建的。===有些人可能反驳，不对！因为： var obj = {a: 10, b: 20};var arr = [5, 'x', true];但是不好意思，这个真的是一种快捷方式，在编程语言中，一般叫做“语法糖”。做语法糖做的最好的可谓是微软大哥，他把他们家c#那小子弄的不男不女，本想图个人见人爱，谁承想还得给别人解释，其实他是个男孩。言归正传，其实以上代码的本质是： //var obj = {a: 10, b: 20};//var arr = [5, ''x'', true];var obj =...","categories": [],
        "tags": ["javascript"],
        "url": "http://localhost:4000/2015/02/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85-2-%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.html"
      },{
        "title": "深入理解javascript原型和闭包（3）——prototype原型",
        "excerpt":"既typeof之后的另一位老朋友。prototype也是我们的老朋友，即使不了解的人，也应该都听过它的大名。如果它还是您的新朋友，我估计您也是javascript 的新朋友。 在第一节中说道，函数也是一种对象，它也是属性集合，也可以对函数进行自定义属性。不用等咱们实验，javascript自己就先做了表率，人家就默认的给函数一个属性，prototype。对，每个函数都有一个属性叫做prototype。这个prototype的属性值是一个对象，（属性的集合，再次强调），默认的只有一个construction的属性，指向这个函数本身。如上图，SuperType是一个函数，右侧的方框就是它的原型。原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如：这个Object大哥，人家的prototype里面就有好几个其他属性。咦，有些方法怎么似曾相识？对，别着急，之后会让你知道他们为何似曾相识。接着往下说，你也可以自定义的方法中prototype中新增自己的属性 function Fn () {} Fn.prototype.name = 'iu2fish'; Fn.prototype.getYear = function () { return 1990; }看到没有，这样就变成了没问题！但是，这样做有何作用呢？解决这个问题，咱们还是先说说jquery吧。 var $div = $('div');$div.attr('myname', 'iu2fish');以上代码中，$(‘div’)返回的时一个对象，对象被函数创建的。假设创建这一对象的函数是myjQuery。它其实是这样实现的。 myjQuery.prototype.attr = function () { //……};$('div') = new myjQuery();不知道大家明白没？如果用自己的代码来演示，就是这样 function Fn ( ) { }Fn.prototype.name = 'iu2fish';Fn.prototype.getYear = function () { rerurn 1990;}var fn = new Fn...","categories": [],
        "tags": ["javscript"],
        "url": "http://localhost:4000/2015/02/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85-3-prototype%E5%8E%9F%E5%9E%8B.html"
      },{
        "title": "深入理解javascript原型和闭包（4）——隐式原型",
        "excerpt":"注意：本文不是javascript基础教程，如果你没有接触过原型的基本知识，应该先去了解一下，推荐看下《javascript高级程序设计第三版第6章：面向对象的程序设计》。上文已经提到，每个函数function都有一个prototype，既原型。这里还要加上一句话，每个对象都有一个 __proto__,可以成为隐式原型。这个__proto__是一个隐藏的属性，javascript不希望开发者用到这个属性，有的低版本浏览器甚至不支持这个属性值。 var obj = {};console.log(`obj.__proto__`);上面截图看来，obj.__proto__和Object.prototype 的属性一样。这么巧。答案就是一样。obj这个对象本质是被Object函数创建的，因此obj.__proto__ === Object.prototype。我们可以用一个图来表示。即，每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。 那么上图中得”Object prototype”也是一个对象，它的__proto__指向哪里？好问题。在说明”Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和var obj = {} 是一样的，都是被Object创建，所以它的__proto__ 指向的就是Object.prototype。但是Object.prototype 确实一个特例，它的__proto__指向的是null，切记切记！ 还有函数也是一种对象，函数也有__proto__吗？又一个好问题，当然有。函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？Function 注意这个F是大写的。且看下面代码 function fn (x, y) { return x + y;}console.log(fn (10, 20));var fn1 = new Function ('x', 'y', 'return x + y');console.log(fn1(5,6));以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Function 创建。首先，根本不推荐用第二种方式。这里只是向大家演示，函数是被Function创建的。 好了，根据上面说的一句话，对象是__proto__ 指向的是创建它的函数prototype，就会出现Object.__proto__ === Function.prototype。用一个图来表示。上图中，很明显的标出了:自定义函数Foo.__prpto__指向Function.prototype,Object.__proto__ 指向Function.prototype,哎，怎么还有一个Fnction.__proto__指向Function.prototype？这不成了循环引用了？对！是一个环形结构。其实稍微想下也就明白了，Function也是一个函数，函数也是一种对象，也有__proto__ 属性。既然是函数，那么一定是被Function创建。所以，Function是被自身创建的。所以他的__proto__指向了自身的prototype.篇幅不少了，估计看的也烦了。快结束了。最后一个问题:Function.prptotype指向的时对象，它的__proto__是不是也指向Object.prototype？答案是肯定的。因为，Function.protype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。Ok本节结束，是不是很乱？乱很正常，那这一节就先乱着，下一节我们将请另一位老朋友来帮忙，把它理清楚。这位老朋友就是instanceof。具体内容下节分享。 摘自：http://www.cnblogs.com/wangfupeng1988/p/3979290.html...","categories": [],
        "tags": ["javascript"],
        "url": "http://localhost:4000/2015/02/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85-4-%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.html"
      },{
        "title": "浅谈javascript中this的指向",
        "excerpt":"浅谈javascript中this的指向 调用位置 在理解this的绑定过程之前，首先要理解调用位置。调用位置就是函数在代码中被调用的位置，而不是声明的位置。只有仔细分析调用位置才能回答这个问题，这个this到底引用什么？通常来说，寻找调用位置，就是寻找函数被调用的位置，但是做起来并没有那么简单，因为某些编程模式可能会隐藏真正的调用位置。最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。下面我们来看看到底什么是调用栈和调用位置： function baz () { //当前调用栈是baz //因此，当前调用位置是全局作用域 console.log(\"baz\"); bar();//bar 的调用位置}function bar () { //当前调用栈是baz-》bar //因此，当前调用位置在baz中 console.log(\"bar\"); foo();}function foo(){ //当前调用栈是baz-》bar-》foo //因此当前调用位置在bar中 console.log(\"foo\");}baz();//&lt;---baz的调用位置注意我们是如何分析出真正的调用位置的，因为它决定了this得绑定。 你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具，其中包含javascript调试器。就本例来说，你可以在工具中给foo函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条debugger语句。运行代码是，调试器会在那个位置暂停，同时会展示当前函数调用列表，这就是你的调用栈。因此，如果你想要分析this的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 绑定规则 1默认绑定 首先思考一下代码： function foo(){ console.log(this.a); } var a = 2; foo();声明在全局作用域中的变量就是对全局对象的一个同名属性。它们本质就是同一个东西。并不是通过复制得到的，就像一个硬币的两面一样。接下来我们可以看到在调用foo 的时候this.a。 被解析成了全局变量a。为什么？因为本例中，函数调用时，应用了默认绑定(好像废话，怎么知道是默认绑定的？接下来会慢慢道来)因此指向全局对象。那么怎么知道这里使用了默认绑定呢？可以通过分析调用位置来看看foo()是如何调用的，在代码中，foo()是直接使用不带任何修饰的函数引用调用的，因此只能使用默认绑定无法应用其他规则。如果使用了use strict模式，那么全局对象则无法使用默认绑定，因此this将会绑定到undefined。 function(){ \"use strict\" console.log(this.a);}var a = 2;foo(); //this is undefined 这里有一个微妙但是非常重要的细节，虽然`this`的绑定规则完全取决于调用位置，但是只有`foo`运行在非`strict...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2015/05/04/%E6%B5%85%E8%B0%88javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91.html"
      },{
        "title": "call、apply之间的区别",
        "excerpt":"在ECMAScript3 给Function的原型定义了2个方法，它们分别是Function.prototype.call和Function.prototype.apply。在实际的开发中，特别是一些函数式编程中，call和apply方法尤其有用。反正我也不懂什么是函数式编程，最近也出了一本javascript方面的书，函数式编程，有兴趣的同学可以自己去看看。###call和apply的区别先说下call和apply的区别，区别嘛，好像就是传入的参数不同，它的作用完全是一样的。apply接受2个参数，第一个参数制定了函数体内this对象的指向。第二个参数为一个带下标的集合，这个集合可以为数组，可以为类数组，apply方法把这个集合中得元素作为参数传递给被调用的函数： var fun = function(a, b, c){ alert([a, b, c]); } fun.apply(null, [1, 2, 3]); //输出的结果就是：[1, 2, 3]这个栗子呢参数1 2 3 被放入数组中，一起传入fun，他们分别对应fun中的a b c。call呢，我自己觉得它就是apply的语法糖，实例化了apply得方法。它的第一个参数也是代表函数体内的this的指向，从第二个参数开始往后，每个参数被依次传入函数。 var fun = function(a, b, c){ alert([a, b, c]); } fun.call(null, 1, 2, 3); //输出的结果就是:[1, 2, 3]当调用一个函数时，javascript的解释器并不会计较形参和实参的数量，类型，以及顺序上得区别，javascript的参数在内部就是用一个数组来表示。从这个意义上，apply比call使用的频率高。因为，编写程序的时候，不用考虑参数的个数，只要一股脑儿的全部丢过去，就好了。call就是包装在apply的语法糖，如果明确地知道函数接收多少个参数，那么就可以一目了然的表达清楚要表达的，如果不是，apply是你最好的选择。如果我们在传入的参数中，第一个是null无论是call或者apply那么函数体内的this都是window，但是如果在严格模式strict下，this还是null。看下面的栗子。 var fun = function(a, b, c){ alert(this === window);...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2015/08/06/call-apply%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.html"
      },{
        "title": "一个 javascript demo 的思考",
        "excerpt":"周末无聊在群里吹水，单身狗的周末日常啊。 突然有小伙伴问了一个问题，看了下确实蛮有意思的： var f1 = function () { var n = 1; Add = function () { n += 1; } return function () { console.log (n); }}var a = f1(), b = f1(), c = f1();a();b();c();Add();a();b();c();好了，大家猜猜输出的结果是啥。我第一眼看到就是，1 1 1 2 2 2 结果并不是。结果而是1 1 1 1 1 2，这个结果还是蛮出乎意料的。为什么是这个结果？首先想到的是，Add()这个函数是全局函数，因为在f1内部没有var定义，所以升级为全局变量，但是，这个不是关键。关键是之后的赋值操作。我们娓娓道来。 var a...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2015/08/29/thinking-of-javascript-demo.html"
      },{
        "title": "Git中级用户的25个提示",
        "excerpt":"作者/Andy JeffriesRuby on Rails 开发者 我使用 Git 大约已经有18个月时间，自认为能很好地驾驭它了。但是当我们请到 GitHub 的 Scott Chacon 来到 LVS 公司（一个博彩/游戏软件供应商/开发商）做专场培训时，我在第一天就学到了大量的东西。 由于有些人总是对使用 Git 自我感觉良好，因此，我想分享一些我从社区获取到的 Git 精品，这样就可能会帮助那些人无需浪费大量研究时间而直接找到答案。 ![](https://raw.githubusercontent.com/iu2fish/_posts/master/media/14428125581957/14428126636942.jpg) &lt;!--more--&gt; ## 基本提示 ### 1.安装之后第一步 安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息： $ git config --global user.name \"Some One\" $ git config --global user.email \"someone@gmail.com\"2. Git 是以指针为基础 存储在 git 中的所有东西都包含在一个文件中。当你提交的时候，git 会创建一个包含提交消息和相关数据的文件（名称、邮件、日期/时间、上一次提交等等），并将其链接到一个树形文件。树形文件包含一个对象列表或者其它树。对象或二进制大数据对象（BLOB）是提交的真正内容（一个文件，如果你愿意，虽然文件名没有存储在对象中，但会存储在树中）。所有这些文件都以对象的 SHA-1 哈希为文件名进行存储。...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2015/10/07/Git%E4%B8%AD%E7%BA%A7%E7%94%A8%E6%88%B7%E7%9A%8425%E4%B8%AA%E6%8F%90%E7%A4%BA.html"
      },{
        "title": "图解 HTTP 之 返回结果的HTTP状态码",
        "excerpt":"状态码的类别 | 标示 | 类别 | 原因短语 || —— | —— | —– || 1XX | Informational（信息性状态码） | 接收的请求正在处理 || 2XX | Success （成功状态码）| 请求正常处理完毕 || 3XX | Redirection （重定向状态码）| 需要附加操作以完成请求|| 4XX | Client Error （客户端错误状态码）| 服务器无法处理请求|| 5XX | Server Error （服务端错误状态码）| 服务器处理请求出错| 2XX 成功 200 ok 表示客户端发来的请求在服务端被正常处理了。 204 No...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2015/10/07/%E5%9B%BE%E8%A7%A3-HTTP-%E4%B9%8B-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html"
      },{
        "title": "携程门票无线组招聘JD",
        "excerpt":"岗位描述   利用各种web技术进行开发，制作标准优化代码，并增加交互动态功能，通过技术来改变用户体验。  负责携程门票业务HTML5版本，携程门票Hybrid APP业务的前端开发工作。岗位要求   掌握JavaScript语言，能够脱离各种JavaScript类库进行跨平台跨浏览器开发。  熟悉各种web前端技术，包括HTML，CSS，JavaScript，但不限于这些。  具有ECMAScript5/HTML5/CSS3/移动设备上前端开发，有NodeJs开发经验更好。  了解研究过各种打包构建工程化工具，Grunt，Gulp，Webpack。  对前端技术有持续的热情，对新技术喜欢瞎折腾，性格乐观开朗，爱读书，爱学习。  最后一条也是最重要的要有一颗责任心，对自己的代码认真负责。备注：此次招聘是社招名额，中高级level，不招实习生。年终奖也领了，想换工作的，来吧，简历发到wangfeng@ctrip.com邮箱，谢谢~ ","categories": [],
        "tags": ["携程","App","无线","ctrip"],
        "url": "http://localhost:4000/2016/03/29/%E6%90%BA%E7%A8%8B%E9%97%A8%E7%A5%A8%E6%97%A0%E7%BA%BF%E7%BB%84%E6%8B%9B%E8%81%98JD.html"
      },{
        "title": "项脊轩志（下）",
        "excerpt":"庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。今伐之，为博小娘子一笑。小娘子一笑，恰似吾妻年少时。小娘子为吾与吾妻之女，今伐树，为小娘子造出嫁之物，愿伉俪情深，不输吾与吾妻。 ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2016/04/17/%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97-%E4%B8%8B.html"
      },{
        "title": "踩了setTimeout的坑",
        "excerpt":"今天测试说，蒹葭同学，uat环境有个bug，秒杀产品还没结束，但是前端显示的是已经结束了，你看一下。我内心OS：妈蛋，又出bug了。不过还是乖乖的去debug了一下代码，最后排查出来是设置的定时器没有生效，直接执行了。 var timer = new Date('xxxx-xx-xx') - new Date('xxxx-xx-xx');setTimeout(function(){ //TODO some code},timer)但是TODO里的代码是直接运行了。what fuck！！怎么会这样，定时器竟然没有起作用。于是查了一下mdn文档。mdn文档这样写道： Maximum delay valueBrowsers including Internet Explorer, Chrome, Safari, and Firefox store the delay as a 32-bit signed integer internally. This causes an integer overflow when using delays larger than 2147483647, resulting in the timeout being executed immediately....","categories": [],
        "tags": ["JavaScript","前端"],
        "url": "http://localhost:4000/2016/06/01/%E8%B8%A9%E4%BA%86setTimeout%E7%9A%84%E5%9D%91.html"
      },{
        "title": "判断this",
        "excerpt":"  函数是否在new中调用new绑定？如果是的话，this 绑定的是新创建的对象。var bar = new foo();  函数是否通过call apply 或者硬绑定调用？如果是的话，this绑定的是指定的对象。 var bar = foo.call(obj);  函数是否在某个上下文对象中调用？如果是的话，this绑定的是那个上下文。var bar = obj.foo();  如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到underfined，否则绑定到全局对象。 var bar = foo();","categories": [],
        "tags": ["JavaScript","this"],
        "url": "http://localhost:4000/2016/07/06/%E5%88%A4%E6%96%ADthis.html"
      },{
        "title": "talk about sesionStorage VS localStorage",
        "excerpt":"最近业务上，有个需求，当一次回话结束，保存的信息，就要销毁。这个一看，正好是sessionStorage的用法，但是之前并没有了解锅sessionStorage，一直是使用localStorage，并且公司的框架封装好了localStorage的用法，所以，趁此机会了解一下sessionStorage的一些API。说起localStorage和sessionStorage，总要说起我们的小甜饼，Cookie。顾名思义，cookie确实非常小，它的大小只有4K左右，是网景公司的前雇员Lou Montulli在1993年3月的发明。它主要用途是用来存放保存登录信息，比如你登录某个网站是可以看到『记住密码』，这通常就是通过在Cookie中存入一段辨别用户的数据来实现的。 localStorage vs sessionStorage localStorage 是html5 标准中新加入的技术，它并不是什么划时代的新东西。早在IE6的时代，就有一个userDate的东西用于本地存储，而当时考虑到浏览器的兼容性，更通用的方案是使用flash，而如今localStorage被大多数浏览器支持，更多的webview支持，尤其是移动端发展很快。 特性 Chrome Firefox IE Opera Safari localStorage 4 3.5 8 10.50 4 sessionStorage 5 2 8 10.50 4 sessionStorage 与localStorage 的接口类似，但保存数据的生命周期与localStorage不同。session对于服务端的童鞋，应该比较了解，但是sessionStorage是个前端的概念。可以将一部分信息存在sessionStorage里，在这次回话结束，页面关闭，sessionStorage中的数据就会被清空。localStorage则不同，它是持久化的，换句话说，如果不这是过期时间，localStorage是不会清空的，前提是，不要手动去清除。而sessionStorage则不是这样，页面关闭，会话结束，保存在sessionStorage的信息就会被清除。除了这个不同，其他的操作API其实都是一样的，无论是sessionStorage还是localStorage，都有setItem，getItem，clear，removeItem这几个API，具体的见mdn官方的文档 常用的API setItem setItem支持k-v这种存值，但是v只能是字符串，所以在存之前，必须要JSON.stringify一下呢。 localStorage.setItem('TEST','value');getItem getItem就比较简单了，只需要localStorage.getItem就可以了，例如： localStorage.getItem('TESTR');removeItem removeItem这个就是移除某个键值的localStorage localStorage.removeItem('TEST');clear clear 这个方法很常用，也很直接，就是直接清空缓存 localStorage.clear();这就是localStorage最常见的几个API了，不过也是最底层的，但是一般公司不会直接这有去操作localStorage的，因为这个太野蛮了，一点都没封装，比如，直接使用setItem的话，是没设置过期时间的，前面也说到，localStorage的大小有5M左右，但是如果localStorage存放满了，过大了，这时候，用户继续存localStorage的话，怎么办？官方mdn文档没有说，但是也有小伙伴也过一篇文章Always catch LocalStorage security and quota exceeded errors，提到了，如何判断是否存满了 function isQuotaExceeded(e) {...","categories": [],
        "tags": ["JavaScript","前端"],
        "url": "http://localhost:4000/2016/07/12/talk-about-sesionStorage-VS-localStorage.html"
      },{
        "title": "团队JavaScript的一些规范",
        "excerpt":"命名规范 全名总体规范 尽量以英文名命名，避免出现拼写错误 //restful返回字段fistchar拼写错误 var firstChar = city.fistchar.toUpperCase(); //框架写错 model.excute(...) //单词拼写不规范 detailinfo.rainfos = pts.modeldata.boxs[0].rainfos; 除非特殊情况，如约定，不得以拼音方式命名（包括注释） //周边 zbAction: function (e) {... 同一含义的命名，统一用一种英文单词，如gologin, gosign, 并且前后端命名一致 ``` //是否登录 isLogin: function () {… //去登录goSignin: function (e) {… 4. 尽量不要缩写，非要缩写，英文缩写按音节，并以辅音结尾 [查看百度文库缩写](http://wenku.baidu.com/link?url=ml6os4CXN0DqPnwI5DWtMlzldz6dGqpoTa_G8lADWUBWyCoMwgFM23uNrrm1ygCSs1zbbacYN9vOuNcgOzG_VOLJuJRALpzy015QKL2xlqu)5. 命名必须望文生意，可读性强 ``` //好 getBoxResById: function (id) { //不好 getRes:function(boxid){ ```6. 禁止使用单字符命名 ``` var p...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2016/08/22/%E5%9B%A2%E9%98%9FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83.html"
      },{
        "title": "eslint 在项目中的使用",
        "excerpt":"前段一段时间，组里搞了jslint，但是，jslint好像没有eslint的配置灵活一些，并且webstrom 也支持eslint，所以就自己搞了一套eslint的检测配置，虽然提交了代码，但是并不强制要求使用。 /********Rules 规则说明'off' 或者 0 - 关闭规则'warn' 或者 1 - 开启规则，使用警告级别的错误，warn 不会导致程序退出'error' 或者 2 - 开启规则，使用错误级别的错误，error 当被触发的时候，程序会退出 @link http://eslint.cn/docs/rules/ @link http://eslint.org/docs/rules/*/{ \"env\": { \"browser\": false, \"node\":true, \"es6\": true }, \"globals\": { }, \"rules\": { \"camelcase\": 2, \"curly\": 0, \"brace-style\": [2, \"1tbs\"], \"quotes\": [2, \"single\"], \"semi\": [2, \"always\"], \"array-bracket-spacing\": [2,...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2016/09/27/eslint-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.html"
      },{
        "title": "微信小程序系列「一」",
        "excerpt":"2016年9月21日，在前端届的确是一个值得纪念的日子。这天，微信放出杀手锏，WeChatApp 又称微信小程序。但是就目前来看，有诸多不便，但是这个事情，依然有很大的意义。因为这是一个生态。从放出来这个消息，就开始关注。加上公司也有内测资格，所以准备写一些文章来聊聊weChatApp开发的一些情况，以及踩到的坑。首先提到的便是1M的大小限制🚫，其实这个看到1M的大小，觉得没什么，但是作为一个大的公司，那么多业务，总共就1M，那么就比较可怜了。算起来我们BU获得的大小容量就100Kb，100Kb是什么概念，纯代码大概只有3000行左右的代码。但是我们之前的代码压缩之后也有235kb呢。反正容量是一个限制。其次：很多官方推荐的API也是不能用的。比如ES6，虽然后来开发工具支持了ES6，但是一些android 机是不支持ES6的，也是呵呵哒。还有官方推荐flex布局，但是在iOS 8及其以下是不支持flex布局的，那怎么办呢？官方给的解释是，自己去做兼容。官方很容易改变API，很多官方组件还没上线呢，就已经废弃了。比如一下的截图：这个就比较尴尬了。很多在内测的公司，估计第一版就是按着官方的组件来的，结果还没上架，你就把官方的组件给废弃了，这是拿内测公司当小白鼠呢。但是，就算是当小白鼠，很多公司还是跪舔着争当小白鼠。下面来说说开发中遇到的坑 setData 以数据来驱动view 在第一版的API中，setData是可以在onLoad的时候，设置数据的，但是更新一次api之后，在onload就不能设置setData了，但是官方的文档，并没有提到这个。还有在setData的时候，如果数据，有多层级。当数据有改变的时候，必须从外层开始设置，例如 obj:{    innerObj:{}}如果在setData的时候写法这样的话，是无效的。 this.setData({\tinnerObj:innerObj})这样是无效的。还有在上面提到，在onload 的时候设置setData无效，那怎么办呢，就像我们的项目，必须设置的话，只能采取官方不推荐或者说，比较猥琐的解决方案。 this.data.obj = obj;虽然官方不推荐，但是也没办法不是吗setData在内部的一个队列方案，这个以后会详细的说，这一篇主要是说说小程序有哪些坑。现在有解决方案的，就把解决方案说一下，没有的话，就是吐槽吧。 数据存储 每个微信小程序都可以有自己的本地缓存，可以通过 wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。本地缓存最大为10MB。在第一版的api中，删除storage是不能指定key进行删除的。那么怎么删除指定的storage呢，只有把当前的key的value值设置为空了。 wx.setStorage({  key:\"key\",  data:\"\"})这个确实也够猥琐的，不过后来的更新中，微信提供了，指定key的删除方法。 wx.removeStorage(OBJECT) 也提供了，同步删除的方法。wx.removeStorageSync(KEY)用法 request请求并发限制 微信为了保证安全，在同时request请求的时候，做了限制，也就是同时并发5个请求，这个暂时无解。只能自己去封装队列来处理请求。request没有cancel的事件，只要这个请求发出去了，是不能取消的。 5层url跳转 微信也是为了安全考虑，限制了，页面跳转的限制，如果层级大于5个的话，不报错，页面就是白页，官方提供的wx.redirectTo去处理，而不是wx.navigateTo。 view的布局以及wxss 官方推荐flex布局，但是当使用form表单的时候，form表单支持flex的并不是很好，使用的时候，要注意。action-sheet 这个东西，很适合做下面的筛选项，但是这个适合少量的数据，因为不能滚动而且自带的样式也是不好控制。呵呵哒。不过也被官方判了死刑，还未上线就被废弃。modal lodding toast，这3个组件已经被官方判了死刑了，还没上线就被废弃。 wxss的一些限制 第一版的时候，wxss不支持层级选择，后来更新的时候，官方把这句话给删除了，也不知道是推荐使用层级还是不支持，反正就是把不支持层级选择给删除了。官方的changelist也没提到这块。iconfont能不能使用？可以，但是ios下有兼容性，如果使用在线的iconfont的话，ios不支持，所以为了包的容量，只能base64在本地了。 另外一些别的坑，如业务交互 这块等下一篇再详细介绍 ","categories": [],
        "tags": ["WeChatApp","javascript","react"],
        "url": "http://localhost:4000/2016/10/27/we-chat-app-pages-1.html"
      },{
        "title": "初识redux",
        "excerpt":"简书 i蒹葭从风转载请注明原创出处，谢谢！如果读完觉得有收获的话，欢迎点赞加关注 简单介绍一下redux 的一些术语和基本概念。 action，reducer，state，store。主要是这4个术语。下面依次来说说这些概念。 action action 本质上是javascript 的普通对象。约定action内使用一个字符串类型的type字段来表示将要执行的动作。很多情况下，type将会定义成字符串常量。例如：const INCREMENT = 'INCREMENT'，另外，当应用项目很大的时候，建议使用单独的模块或文件来存放action。除了type字段以外，action 对象的结构完全有开发者自己决定。 reducer reducer 是个形式为(state, action) =&gt; state 的纯函数 ，描述了action 如何把state 转变成下一个state。 Reducer 这个名称来源于Array.prototype.reduce中的第一个参数，reducer 。reducer 是一个累加器函数，它的参数是上个累加值和数组当前元素，然后通过计算返回本次的累加值。在redux中，state 就是那个累加值，action 就是数组当前的元素。reduce 以及map filter 等方法是函数式编程中十分常用的数组处理方法。state 的形式取决于开发者项目的需要，可是是基本类型，数组，是对象，甚至是immutable.js 生成的数据结构。唯一的点是当state 变化时需要返回全新的对象，而不是修改传入的参数。reducer 要用纯函数。那么什么是纯函数。 纯函数 纯函数 pure function 是这样一种函数，输入输出数据流全是显式的，显式的意思是，函数与外界交换数据只有一个唯一的渠道，参数和返回值。函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过函数返回值传递到该函数外部。纯函数不能访问外部变量，它能接触的外部参数只有来自外部的参数。纯函数不能修改参数，因为这样做可能会把一些信息通过输入参数夹带到外界。reducer 就是这样的纯函数，永远不要在reducer 里做一下操作： 修改传入的参数 执行有副作用的操作，比如：请求API和路由跳转 调用非纯函数，如 new Data.now(),Math.random() 函数副作用会给应用带来不可预测的麻烦，产生难以预测的效果。严格的函数式语言要求函数必须无副作用。 不能修改参数 state...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2017/05/07/%E5%88%9D%E8%AF%86redux.html"
      },{
        "title": "redux 之 middleware ",
        "excerpt":"在回调中分发一个 action ，reducer 收到 action 后，更新 state 并通知 view 重新渲染。单向数据流，看着没什么问题，但是，如果需要打印每一个 action 信息来调试，就得去改 dispatch 或者 reducer 实现，使其具有打印日志的功能。又比如，点击 button 后，需要先去服务端请求数据，只有等数据返回后，才能重新渲染 view ，此时我们希望 dispatch 或者 reducer 拥有异步请求的功能。再比如，需要异步请求数据返回后，打印一条日志，再请求数据，再打印日志，再渲染。面对多样的业务场景，单纯的修改 dispatch 或者 reducer 的代码显然不具有普适性么，我们需要的是可以组合的，自由拔插的插件机制，这一点 redux 借鉴了koa里的 middleware 的思想，另外 redux 中的 reducer 更关心的是数据的转化逻辑，所以 middleware 就是为了增强 dispatch 而出现的。展示了应用middleware 后 redux 处理事件的逻辑，每一个 middleware 处理一个相对独立的业务需求，通过串联不同的middleware 实现变化多样的功能。 currying 的middleware 结构的好处主要有以下两点： 易串联...","categories": [],
        "tags": ["redux","javascript"],
        "url": "http://localhost:4000/2017/06/05/redux-%E4%B9%8B-middleware.html"
      },{
        "title": "NPM Version 导致的一个Bug",
        "excerpt":"起因 事情是这样的，一大早，测试小哥哥就说，新版的RN项目，怎么发布失败呀，你来解决一下。我打开打包日志，发现有一条错误的日志log。未找到项目依赖的React-Native然后我就慢慢的debug，看看发现是哪里有依赖写的不对，导致的。debug了一上午。删掉本地的node_module 重新npm install 之后，发现有一个依赖包，始终安装不了。提示的报错文案npm ERR! Invalid version: \"2.10\" 然后突然看到2.10，npm version的格式不是x.x.x这种么？我怎么会手抖写成了2.10呢，于是改成只正确的版本信息，提交之后，就可以打包了。 思考 该用工具管理的时候，就用工具管理，比如这个version就应该用npm version工具自己管理自己，不要手抖自己去做change。不要太相信自己的代码，出了问题，基本上是自己的问题，打包工具，有可能出现问题，但是，自己的代码，出现问题的概率更大。工程化构建过程，还需要继续努力。 ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2018/07/25/NPM-Version-%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E4%B8%AABug.html"
      },{
        "title": "扫码登录了解多少",
        "excerpt":"周末，想写一个即刻app的微信小程序，通过web端的页面，抓取了一些接口API，但是都需要auth。然后看下，auth从哪获取的，然后发现是扫码之后，通过接口拿到的。然后分析了一下，也算知道了，扫码登录的一些实现方式。 step 1 通过一个接口获取唯一的UUID，同时这个UUID也是有过期时间的。即刻好像是2分钟。 step 2 拿到这个UUID，再加上一些参数，生成一个二维码。在页面上展示。同时调用验证接口，传入生成的UUID。 step 3 拿出手机，用已经登录之后的app扫第二步生成的二维码。在手机上点确认。如果点了确认，第二步的验证接口会返回true。这时候，再调用另外一个confirm接口。 step 4 调用confirm接口，这时候，返回的数据就有auth的值了，这时候把auth的值保存在localstorage里，就可以做成登录态了。这个就是简单的，扫码登录的原理。 挖个坑 不过原理很简单，但是实现起来，却不简单。具体的实现，可能会有一些意向不到的问题。虽然，调用即刻的扫码登录，已经成功，但是具体接口API内部怎么实现的，我还不知道，先挖个坑，以后有时间，自己写一个吧。 ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2018/07/30/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91.html"
      },{
        "title": "A few firendy tips for your javascript",
        "excerpt":"JavaScript is a very loose programming language. By saying that I mean it’s so easy to write heaps of crap that still works, however it will be hard to maintain and to extend. In this post I’d love to present some quick and friendly tips for JavaScript beginners and it...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2020/12/31/A-Few-Friendly-Tips-For-Your-JavaScript.html"
      },{
        "title": "2020年终复盘",
        "excerpt":"又到了写年终总结的时候了，刚毕业那几年每年都会写，断了几年，今年发生的事情太多了，还是记录一下吧。 疫情 年初，疫情大规模爆发，在家看新闻，大年三十晚上是最撕裂的一天吧，电视里歌舞升平，现实呢，后来武汉解封问了从武汉回来的同事，我说，春节期间网上流传的视频是真的么？他说是真的，真相远比网上流传的视频要震撼的多的多。怕封路，在家也没呆几天就匆匆的返回上海。一路上见了很多奇奇怪怪的事，比如乡下用土堆封路，比如租售待遇不一样，同一个小区，都是从外地返回，业主可以直接进去，租赁的租户就不可以进去，奇奇怪怪的事太多了。觉得自己被冒犯，可是哪有如何呢，很多人都说自己见证了历史，可是历史不是每天都是么。 生活 2020对我来说就是角色的转变吧。计划结婚是从5月份开始，这期间要办理户口，买房，订婚，领证，结婚。这一系列的流程真的是不可多言。大概是3.4月份的时候，女票说我们去看看房子吧，最近房价好像挺适合上车的。再加上疫情初期时候的，租售同权伤了我，听她这么一说，再加上她的一个表舅是二手房中介，就咨询了一下，对方说，房子这事如果是自住，早买早好。于是在4月份的时候，算了下手里的现金，加上把理财的钱，七七八八加起来，算了下，差不多够首付，于是开启了看房之旅。 买房 因为限购，我又没有交社保，所以先看的都是不限购区域，女票先是看中了一套洋房，看样板房，双阳台，各种都满意，但是手里的首付不满意。所以洋房的打算就撤了，后面发现可以直接落户，这样就可以购买限购的区域，于是开始了折腾户口的事情，从开始申请户口，到后面拿到户口本，前前后后，花了差不多一个月吧。五一期间也看中了新房，交了意向金，就等着开盘了。开盘那天是5月30号，天还下着小雨，临时通知我们开盘了，我们急匆匆的赶过去，还好还好，最后选到了心仪的楼层和户型。5月31日，交了首付款。 领证 6.1领证，也算是意外的，本来是打算12.25去领证的，因为那是在一起的纪念日，但是买房的事赶的急，就临时觉得6.1领证也蛮好的，以后可以2个节日一起过。领证那天也是蛮逗的，因为女票匆匆出门，忘了带户口本。要不是我提醒，估计我们那天就领不了证了，前几天，老婆问我，你2020哪件事印象最深？我说当然是结婚啊。她说，你猜我是哪件事？我说，你肯定是领证那天忘了带户口本。哈哈哈哈哈哈哈哈哈哈哈，她说你真聪明。 定亲 从6月份到7月底一直在忙碌这件事。因为是异地，定亲我家里人要过来，我老婆家也不在我工作地，所以，只能两地奔波去忙碌这件事，老婆一起搞，帮忙订酒店，饭店，确定菜单，酒水。最后也不负付出，没出啥大乱子。 回老家结婚 十一回去结婚，这个都是我爸在弄，我和老婆就是2个工具人，也没啥事，就是十一家里好冷，哈哈，岳父母到了之后说，怎么那么冷。 扬州 国庆假期结束之后，返回上海的时候，发现途径扬州，于是就暂作停留，在扬州玩了2天，十年之后再次去扬州和大学时时不一样的，或许是在江南看多了，到了扬州觉得一般般，不是十年前去的那个扬州了。 工作 这一年的工作，总体没啥大的变化，除了因为疫情，收入没有涨，其他还行，就是中间穿插了点小插曲。因为组织架构调整的原因，遇到不淑的同事，也算是无话可说，幸好及时调整，也算是及时止损吧。 电池产品 今年是买苹果产品最多的一年 iPhone 12 Pro Max *2 iPhone 12 * 1 Apple Watch 5 * 1 iPad Air 3 * 1 iPad Air 4 * 1 AirPods Pro * 1 Apple Pencil *...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/2020/12/31/new-year.html"
      }]
