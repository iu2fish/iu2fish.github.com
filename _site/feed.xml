<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-31T19:19:38+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">蒹葭从风</title><subtitle>📖📖📖</subtitle><entry><title type="html">2020年终复盘</title><link href="http://localhost:4000/2020/12/31/new-year.html" rel="alternate" type="text/html" title="2020年终复盘" /><published>2020-12-31T15:13:29+08:00</published><updated>2020-12-31T15:13:29+08:00</updated><id>http://localhost:4000/2020/12/31/new-year</id><content type="html" xml:base="http://localhost:4000/2020/12/31/new-year.html">&lt;p&gt;又到了写年终总结的时候了，刚毕业那几年每年都会写，断了几年，今年发生的事情太多了，还是记录一下吧。&lt;/p&gt;
&lt;h2 id=&quot;疫情&quot;&gt;疫情&lt;/h2&gt;
&lt;p&gt;年初，疫情大规模爆发，在家看新闻，大年三十晚上是最撕裂的一天吧，电视里歌舞升平，现实呢，后来武汉解封问了从武汉回来的同事，我说，春节期间网上流传的视频是真的么？他说是真的，真相远比网上流传的视频要震撼的多的多。怕封路，在家也没呆几天就匆匆的返回上海。一路上见了很多奇奇怪怪的事，比如乡下用土堆封路，比如租售待遇不一样，同一个小区，都是从外地返回，业主可以直接进去，租赁的租户就不可以进去，奇奇怪怪的事太多了。觉得自己被冒犯，可是哪有如何呢，很多人都说自己见证了历史，可是历史不是每天都是么。&lt;/p&gt;

&lt;h2 id=&quot;生活&quot;&gt;生活&lt;/h2&gt;
&lt;p&gt;2020对我来说就是角色的转变吧。计划结婚是从5月份开始，这期间要办理户口，买房，订婚，领证，结婚。这一系列的流程真的是不可多言。大概是3.4月份的时候，女票说我们去看看房子吧，最近房价好像挺适合上车的。再加上疫情初期时候的，租售同权伤了我，听她这么一说，再加上她的一个表舅是二手房中介，就咨询了一下，对方说，房子这事如果是自住，早买早好。于是在4月份的时候，算了下手里的现金，加上把理财的钱，七七八八加起来，算了下，差不多够首付，于是开启了看房之旅。&lt;/p&gt;
&lt;h3 id=&quot;买房&quot;&gt;买房&lt;/h3&gt;
&lt;p&gt;因为限购，我又没有交社保，所以先看的都是不限购区域，女票先是看中了一套洋房，看样板房，双阳台，各种都满意，但是手里的首付不满意。所以洋房的打算就撤了，后面发现可以直接落户，这样就可以购买限购的区域，于是开始了折腾户口的事情，从开始申请户口，到后面拿到户口本，前前后后，花了差不多一个月吧。五一期间也看中了新房，交了意向金，就等着开盘了。开盘那天是5月30号，天还下着小雨，临时通知我们开盘了，我们急匆匆的赶过去，还好还好，最后选到了心仪的楼层和户型。5月31日，交了首付款。&lt;/p&gt;
&lt;h3 id=&quot;领证&quot;&gt;领证&lt;/h3&gt;
&lt;p&gt;6.1领证，也算是意外的，本来是打算12.25去领证的，因为那是在一起的纪念日，但是买房的事赶的急，就临时觉得6.1领证也蛮好的，以后可以2个节日一起过。领证那天也是蛮逗的，因为女票匆匆出门，忘了带户口本。要不是我提醒，估计我们那天就领不了证了，前几天，老婆问我，你2020哪件事印象最深？我说当然是结婚啊。她说，你猜我是哪件事？我说，你肯定是领证那天忘了带户口本。哈哈哈哈哈哈哈哈哈哈哈，她说你真聪明。&lt;/p&gt;
&lt;h3 id=&quot;定亲&quot;&gt;定亲&lt;/h3&gt;
&lt;p&gt;从6月份到7月底一直在忙碌这件事。因为是异地，定亲我家里人要过来，我老婆家也不在我工作地，所以，只能两地奔波去忙碌这件事，老婆一起搞，帮忙订酒店，饭店，确定菜单，酒水。最后也不负付出，没出啥大乱子。&lt;/p&gt;
&lt;h3 id=&quot;回老家结婚&quot;&gt;回老家结婚&lt;/h3&gt;
&lt;p&gt;十一回去结婚，这个都是我爸在弄，我和老婆就是2个工具人，也没啥事，就是十一家里好冷，哈哈，岳父母到了之后说，怎么那么冷。&lt;/p&gt;
&lt;h3 id=&quot;扬州&quot;&gt;扬州&lt;/h3&gt;
&lt;p&gt;国庆假期结束之后，返回上海的时候，发现途径扬州，于是就暂作停留，在扬州玩了2天，十年之后再次去扬州和大学时时不一样的，或许是在江南看多了，到了扬州觉得一般般，不是十年前去的那个扬州了。&lt;/p&gt;

&lt;h2 id=&quot;工作&quot;&gt;工作&lt;/h2&gt;
&lt;p&gt;这一年的工作，总体没啥大的变化，除了因为疫情，收入没有涨，其他还行，就是中间穿插了点小插曲。因为组织架构调整的原因，遇到不淑的同事，也算是无话可说，幸好及时调整，也算是及时止损吧。&lt;/p&gt;
&lt;h2 id=&quot;电池产品&quot;&gt;电池产品&lt;/h2&gt;
&lt;p&gt;今年是买苹果产品最多的一年&lt;/p&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;iPhone 12 Pro Max *2&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;iPhone 12 * 1&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Apple Watch 5 * 1&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;iPad Air 3 * 1&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;iPad Air 4 * 1&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;AirPods Pro * 1&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Apple Pencil * 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;希望明年少买一些吧，太贵了。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;要说遗憾，有很多未完成的吧，也有很多不愉快，比如因为订婚，结婚，意见的分歧，幸好最后大家统一了意见。比如婚纱照，拍了2次还是不满意，最后退款，和影楼闹的不欢而散。比如未能出去玩，2019年底的计划，但是总的来说，2020还是收获很多的。靠自己买房，结婚，我可以傲娇的说，买房我没有啃老，没有用6个钱包，都是我自己一行代码一行代码码出来的。老婆说，以后我们要做一年和五年规划。虽然2021和2020不会有大的差别，寒潮依然在，温度依然是寒冷的，但是仪式感还是要有的。&lt;/p&gt;
&lt;h2 id=&quot;2021规划&quot;&gt;2021规划&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;把户口落到上海&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;学会驾照&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;买个车车&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第一个五年计划&quot;&gt;第一个五年计划&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;要个宝宝&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">又到了写年终总结的时候了，刚毕业那几年每年都会写，断了几年，今年发生的事情太多了，还是记录一下吧。 疫情 年初，疫情大规模爆发，在家看新闻，大年三十晚上是最撕裂的一天吧，电视里歌舞升平，现实呢，后来武汉解封问了从武汉回来的同事，我说，春节期间网上流传的视频是真的么？他说是真的，真相远比网上流传的视频要震撼的多的多。怕封路，在家也没呆几天就匆匆的返回上海。一路上见了很多奇奇怪怪的事，比如乡下用土堆封路，比如租售待遇不一样，同一个小区，都是从外地返回，业主可以直接进去，租赁的租户就不可以进去，奇奇怪怪的事太多了。觉得自己被冒犯，可是哪有如何呢，很多人都说自己见证了历史，可是历史不是每天都是么。</summary></entry><entry><title type="html">A few firendy tips for your javascript</title><link href="http://localhost:4000/2020/12/31/A-Few-Friendly-Tips-For-Your-JavaScript.html" rel="alternate" type="text/html" title="A few firendy tips for your javascript" /><published>2020-12-31T15:13:29+08:00</published><updated>2020-12-31T15:13:29+08:00</updated><id>http://localhost:4000/2020/12/31/A-Few-Friendly-Tips-For-Your-JavaScript</id><content type="html" xml:base="http://localhost:4000/2020/12/31/A-Few-Friendly-Tips-For-Your-JavaScript.html">&lt;p&gt;JavaScript is a very loose programming language. By saying that I mean it’s so easy to write heaps of crap that still works, however it will be hard to maintain and to extend. In this post I’d love to present some quick and friendly tips for JavaScript beginners and it might be able to help you. Now relax and let’s get started.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;know-your-target&quot;&gt;Know your target&lt;/h3&gt;
&lt;p&gt;Before you start writing any code, please spend a few minutes to figure out a simple question: which browsers will you write for?. Knowing your target (browser) can make a big difference because we all know the moderner the browser is, the more power you gain.&lt;/p&gt;

&lt;p&gt;We all know how to loop an array:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var list = [1, 2, 3];
for (var i = 0; i &amp;lt; list.length; i++) {
  var current = list[i];
  // more code omitted...
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Later on you learned the power of jQuery, and then you started to make it simpler:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var list = [1, 2, 3];
$.each(list, function(index, value) {
  // more code omitted...
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now the problem is that a lot developers just don’t know that if you are targeting a browser which supports ES5, you have the full support of wrting
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array.prototype.forEach&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var list = [1, 2, 3];
list.forEach(function(element, index) {
  // more code omitted...
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And if you dig a little bit more, you should find that even IE 9 supports ES5. This may not sound over exciting, but if you check this list, you can find a lot array functions natively supported. You can gain the power of map, reduce and filter etc. This means if you are NOT writing JavaScript for old browsers, you already have much more convenience. Happy?&lt;/p&gt;

&lt;p&gt;Alright, let’s say you are still writing code for old browsers. Worry not, there’re &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;shims&lt;/a&gt; which can “trick” old browsers so that you can use ES5 functions on them.&lt;/p&gt;

&lt;p&gt;Thus, know your enemy, know your browser.&lt;/p&gt;

&lt;h3 id=&quot;be-functional&quot;&gt;Be functional&lt;/h3&gt;
&lt;p&gt;Maybe you have heard of &lt;a href=&quot;http://stackoverflow.com/questions/24279/functional-programming-and-non-functional-programming&quot;&gt;functional programming&lt;/a&gt; already. This could be extremely handy when you write JavaScript.&lt;/p&gt;

&lt;p&gt;A typical example is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array.prototype.map&lt;/code&gt;, which takes a function as input, and outputs a function in which each element is a projection of the elements from input function. Let’s have a look at the example below.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var oddNumbers = [1, 3, 5];
oddNumbers.forEach(function(x) {
  console.log(x);
}); // output 1, 3, 5
var evenNumbers = oddNumbers.map(function(x) {
    return x + 1;
  })
  .forEach(function(x) {
    console.log(x);
  }); // output 2, 4, 6

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can see that we map each number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x &lt;/code&gt;in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;oddNumbers&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x + 1&lt;/code&gt; so that we got the evenNumbers.
 Functional programming style is usually written in chained methods. Check the following example.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
  { name: 'product 1', price: 10 },
  { name: 'product 2', price: 20 },
  { name: 'product 3', price: 30 }
].filter(function(x) {
  return x.price &amp;gt; 10;
})
.map(function(x) {
  return x.price;
})
.reduce(function(x, y) {
  return x + y
}); // 50

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In the code above, we first filter out products whose prices are greater than 10, then we create an array of prices on the fly, and finally we aggregate the prices to get the total price. This kind of pattern can be very powerful and flexible.&lt;/p&gt;

&lt;h3 id=&quot;lint-your-javascript&quot;&gt;Lint your JavaScript&lt;/h3&gt;

&lt;p&gt;If by now you still don’t know what lint is, you might already have produced a lot “bad code”. As I mentioned in the beginning, JavaScript (actually most dynamic script languages) is very loose, and unlike C#, Java, etc. you only see errors when it gets executed; in other words, you see runtime errors only. This could be quite annoying because some of those errors are human mistakes which are hard to detect by mortals’ eyes. JavaScript linting is a process that can help you avoid cheap errors and improve code quality, standard as well as consistency.&lt;/p&gt;

&lt;p&gt;There’re many tools that can help you with linting, but I strongly recommend &lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;, since it supports future JavaScript standard such as ES6. You can, of course just install eslint and use it straightaway, but I challenge you to have a look at &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;, and then find a way to make your linting process automatic, which means everytime you save a file, it will be scanned by ESLint.&lt;/p&gt;

&lt;p&gt;In the meantime, I have a bonus for you. Go to have a look at the &lt;a href=&quot;http://ktei.github.io/2016/01/07/(https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb)&quot;&gt;ESLint config&lt;/a&gt; provided by Airbnb. You can follow the readme file to configure your ESLint as strict as theirs. So easy to be professional, right?&lt;/p&gt;

&lt;p&gt;Okay, these are just tips of Part 1. It shall be continued…&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;转载自：http://ktei.github.io/2016/01/07/some-general-js-tips-1.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">JavaScript is a very loose programming language. By saying that I mean it’s so easy to write heaps of crap that still works, however it will be hard to maintain and to extend. In this post I’d love to present some quick and friendly tips for JavaScript beginners and it might be able to help you. Now relax and let’s get started. Know your target Before you start writing any code, please spend a few minutes to figure out a simple question: which browsers will you write for?. Knowing your target (browser) can make a big difference because we all know the moderner the browser is, the more power you gain.</summary></entry><entry><title type="html">扫码登录了解多少</title><link href="http://localhost:4000/2018/07/30/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91.html" rel="alternate" type="text/html" title="扫码登录了解多少" /><published>2018-07-30T07:39:12+08:00</published><updated>2018-07-30T07:39:12+08:00</updated><id>http://localhost:4000/2018/07/30/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91</id><content type="html" xml:base="http://localhost:4000/2018/07/30/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91.html">&lt;p&gt;周末，想写一个即刻app的微信小程序，通过web端的页面，抓取了一些接口API，但是都需要auth。然后看下，auth从哪获取的，然后发现是扫码之后，通过接口拿到的。
然后分析了一下，也算知道了，扫码登录的一些实现方式。&lt;/p&gt;
&lt;h4 id=&quot;step-1&quot;&gt;step 1&lt;/h4&gt;
&lt;p&gt;通过一个接口获取唯一的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UUID&lt;/code&gt;，同时这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UUID&lt;/code&gt;也是有过期时间的。即刻好像是2分钟。&lt;/p&gt;
&lt;h4 id=&quot;step-2&quot;&gt;step 2&lt;/h4&gt;
&lt;p&gt;拿到这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UUID&lt;/code&gt;，再加上一些参数，生成一个二维码。在页面上展示。同时调用验证接口，传入生成的UUID。&lt;/p&gt;
&lt;h4 id=&quot;step-3&quot;&gt;step 3&lt;/h4&gt;
&lt;p&gt;拿出手机，用已经登录之后的app扫第二步生成的二维码。在手机上点确认。如果点了确认，第二步的验证接口会返回true。这时候，再调用另外一个confirm接口。&lt;/p&gt;
&lt;h4 id=&quot;step-4&quot;&gt;step 4&lt;/h4&gt;
&lt;p&gt;调用confirm接口，这时候，返回的数据就有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth&lt;/code&gt;的值了，这时候把auth的值保存在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localstorage&lt;/code&gt;里，就可以做成登录态了。
这个就是简单的，扫码登录的原理。
&lt;!--more--&gt;&lt;/p&gt;
&lt;h4 id=&quot;挖个坑&quot;&gt;挖个坑&lt;/h4&gt;
&lt;p&gt;不过原理很简单，但是实现起来，却不简单。具体的实现，可能会有一些意向不到的问题。虽然，调用即刻的扫码登录，已经成功，但是具体接口API内部怎么实现的，我还不知道，先挖个坑，以后有时间，自己写一个吧。&lt;/p&gt;</content><author><name></name></author><summary type="html">周末，想写一个即刻app的微信小程序，通过web端的页面，抓取了一些接口API，但是都需要auth。然后看下，auth从哪获取的，然后发现是扫码之后，通过接口拿到的。 然后分析了一下，也算知道了，扫码登录的一些实现方式。 step 1 通过一个接口获取唯一的UUID，同时这个UUID也是有过期时间的。即刻好像是2分钟。 step 2 拿到这个UUID，再加上一些参数，生成一个二维码。在页面上展示。同时调用验证接口，传入生成的UUID。 step 3 拿出手机，用已经登录之后的app扫第二步生成的二维码。在手机上点确认。如果点了确认，第二步的验证接口会返回true。这时候，再调用另外一个confirm接口。 step 4 调用confirm接口，这时候，返回的数据就有auth的值了，这时候把auth的值保存在localstorage里，就可以做成登录态了。 这个就是简单的，扫码登录的原理。 挖个坑 不过原理很简单，但是实现起来，却不简单。具体的实现，可能会有一些意向不到的问题。虽然，调用即刻的扫码登录，已经成功，但是具体接口API内部怎么实现的，我还不知道，先挖个坑，以后有时间，自己写一个吧。</summary></entry><entry><title type="html">NPM Version 导致的一个Bug</title><link href="http://localhost:4000/2018/07/25/NPM-Version-%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E4%B8%AABug.html" rel="alternate" type="text/html" title="NPM Version 导致的一个Bug" /><published>2018-07-25T07:27:47+08:00</published><updated>2018-07-25T07:27:47+08:00</updated><id>http://localhost:4000/2018/07/25/NPM-Version-%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E4%B8%AABug</id><content type="html" xml:base="http://localhost:4000/2018/07/25/NPM-Version-%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E4%B8%AABug.html">&lt;h3 id=&quot;起因&quot;&gt;起因&lt;/h3&gt;
&lt;p&gt;事情是这样的，一大早，测试小哥哥就说，新版的RN项目，怎么发布失败呀，你来解决一下。我打开打包日志，发现有一条错误的日志log。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;未找到项目依赖的React-Native&lt;/code&gt;
然后我就慢慢的debug，看看发现是哪里有依赖写的不对，导致的。debug了一上午。删掉本地的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_module&lt;/code&gt; 重新npm install 之后，发现有一个依赖包，始终安装不了。
提示的报错文案
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm ERR! Invalid version: &quot;2.10&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后突然看到2.10，npm version的格式不是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x.x.x&lt;/code&gt;这种么？我怎么会手抖写成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.10&lt;/code&gt;呢，于是改成只正确的版本信息，提交之后，就可以打包了。
&lt;!-- more --&gt;&lt;/p&gt;
&lt;h3 id=&quot;思考&quot;&gt;思考&lt;/h3&gt;
&lt;p&gt;该用工具管理的时候，就用工具管理，比如这个version就应该用npm version工具自己管理自己，不要手抖自己去做change。
不要太相信自己的代码，出了问题，基本上是自己的问题，打包工具，有可能出现问题，但是，自己的代码，出现问题的概率更大。
工程化构建过程，还需要继续努力。&lt;/p&gt;</content><author><name></name></author><summary type="html">起因 事情是这样的，一大早，测试小哥哥就说，新版的RN项目，怎么发布失败呀，你来解决一下。我打开打包日志，发现有一条错误的日志log。 未找到项目依赖的React-Native 然后我就慢慢的debug，看看发现是哪里有依赖写的不对，导致的。debug了一上午。删掉本地的node_module 重新npm install 之后，发现有一个依赖包，始终安装不了。 提示的报错文案 npm ERR! Invalid version: &quot;2.10&quot;</summary></entry><entry><title type="html">redux 之 middleware</title><link href="http://localhost:4000/2017/06/05/redux-%E4%B9%8B-middleware.html" rel="alternate" type="text/html" title="redux 之 middleware" /><published>2017-06-05T06:58:00+08:00</published><updated>2017-06-05T06:58:00+08:00</updated><id>http://localhost:4000/2017/06/05/redux-%E4%B9%8B-middleware</id><content type="html" xml:base="http://localhost:4000/2017/06/05/redux-%E4%B9%8B-middleware.html">&lt;p&gt;在回调中分发一个 action ，reducer 收到 action 后，更新 state 并通知 view 重新渲染。单向数据流，看着没什么问题，但是，如果需要打印每一个 action 信息来调试，就得去改 dispatch 或者 reducer 实现，使其具有打印日志的功能。又比如，点击 button 后，需要先去服务端请求数据，只有等数据返回后，才能重新渲染 view ，此时我们希望 dispatch 或者 reducer 拥有异步请求的功能。再比如，需要异步请求数据返回后，打印一条日志，再请求数据，再打印日志，再渲染。
&lt;!-- more --&gt;
面对多样的业务场景，单纯的修改 dispatch 或者 reducer 的代码显然不具有普适性么，我们需要的是可以组合的，自由拔插的插件机制，这一点 redux 借鉴了koa里的 middleware 的思想，另外 redux 中的 reducer 更关心的是数据的转化逻辑，所以 middleware 就是为了增强 dispatch 而出现的。
展示了应用middleware 后 redux 处理事件的逻辑，每一个 middleware 处理一个相对独立的业务需求，通过串联不同的middleware 实现变化多样的功能。&lt;/p&gt;

&lt;p&gt;currying 的middleware 结构的好处主要有以下两点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;易串联 currying 函数具有延迟执行的特性，通过不断currying 形成的middleware 可以 i累积参数，再配合 compose 的方式，很容易形成pipeline 来处理数据流。&lt;/li&gt;
  &lt;li&gt;共享store 在 appleMiddleware 执行的过程中，store 还是旧的，但是 因为闭包的存在，applyMiddleware 完成后，所有middleware 内部拿到的store 是最新且相同的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，我们会发现，applyMiddleware 的结构也是一个多层currying 函数，借助compose applyMiddleware 可以用来和其他插件加强createStore 函数。&lt;/p&gt;

&lt;h2 id=&quot;给middleware-分发store&quot;&gt;给middleware 分发store&lt;/h2&gt;
&lt;p&gt;通过如下方式创建一个普通的 store 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let newstore = applyMiddleware(mid1, mid2,mid3,...)(createStore)(reducer, null)&lt;/code&gt;;
上述代码执行后，applymiddleware 方法陆续得到了3个参数，第一个是middlewares 数组，第二个是redux 原生的 createStore 最后一个是reducer 。然后，我们可以看到applyMiddleware 利用createStore 和 reducer 创建了一个store。 而store 的getState 方法和 dispatch 方法又分别被直接和间接的赋值给middlewareAPI变量store：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const middlewareAPI = {
	getState: store.getState,
	dispatch: (action)=&amp;gt; dispatch(action)
};
chain = middlewares.map(middleware =&amp;gt; middleware(middlewareAPI))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，让每个middleware 带着middleware API 这个参数分别执行一遍。执行完后，获得chain 数组，f1,f2,f3,…fx,…fn，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数可以访问相同的store， 即middleware API。&lt;/p&gt;</content><author><name>蒹葭从风</name></author><category term="redux" /><category term="javascript" /><summary type="html">在回调中分发一个 action ，reducer 收到 action 后，更新 state 并通知 view 重新渲染。单向数据流，看着没什么问题，但是，如果需要打印每一个 action 信息来调试，就得去改 dispatch 或者 reducer 实现，使其具有打印日志的功能。又比如，点击 button 后，需要先去服务端请求数据，只有等数据返回后，才能重新渲染 view ，此时我们希望 dispatch 或者 reducer 拥有异步请求的功能。再比如，需要异步请求数据返回后，打印一条日志，再请求数据，再打印日志，再渲染。 面对多样的业务场景，单纯的修改 dispatch 或者 reducer 的代码显然不具有普适性么，我们需要的是可以组合的，自由拔插的插件机制，这一点 redux 借鉴了koa里的 middleware 的思想，另外 redux 中的 reducer 更关心的是数据的转化逻辑，所以 middleware 就是为了增强 dispatch 而出现的。 展示了应用middleware 后 redux 处理事件的逻辑，每一个 middleware 处理一个相对独立的业务需求，通过串联不同的middleware 实现变化多样的功能。</summary></entry><entry><title type="html">初识redux</title><link href="http://localhost:4000/2017/05/07/%E5%88%9D%E8%AF%86redux.html" rel="alternate" type="text/html" title="初识redux" /><published>2017-05-07T00:10:06+08:00</published><updated>2017-05-07T00:10:06+08:00</updated><id>http://localhost:4000/2017/05/07/%E5%88%9D%E8%AF%86redux</id><content type="html" xml:base="http://localhost:4000/2017/05/07/%E5%88%9D%E8%AF%86redux.html">&lt;blockquote&gt;
  &lt;p&gt;简书 &lt;a href=&quot;http://www.jianshu.com/u/1578eaace5b4&quot;&gt;i蒹葭从风&lt;/a&gt;
转载请注明原创出处，谢谢！
如果读完觉得有收获的话，欢迎点赞加关注&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单介绍一下redux 的一些术语和基本概念。 action，reducer，state，store。主要是这4个术语。下面依次来说说这些概念。&lt;/p&gt;

&lt;h2 id=&quot;action&quot;&gt;action&lt;/h2&gt;
&lt;p&gt;action 本质上是javascript 的普通对象。约定action内使用一个字符串类型的type字段来表示将要执行的动作。很多情况下，type将会定义成字符串常量。例如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const INCREMENT = 'INCREMENT'&lt;/code&gt;，另外，当应用项目很大的时候，建议使用单独的模块或文件来存放action。除了type字段以外，action 对象的结构完全有开发者自己决定。&lt;/p&gt;
&lt;h2 id=&quot;reducer&quot;&gt;reducer&lt;/h2&gt;
&lt;p&gt;reducer 是个形式为(state, action) =&amp;gt; state 的纯函数 ，描述了action 如何把state 转变成下一个state。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Reducer  这个名称来源于Array.prototype.reduce中的第一个参数，reducer 。reducer 是一个累加器函数，它的参数是上个累加值和数组当前元素，然后通过计算返回本次的累加值。在redux中，state 就是那个累加值，action 就是数组当前的元素。reduce 以及map filter 等方法是函数式编程中十分常用的数组处理方法。
&lt;!-- more --&gt;
state 的形式取决于开发者项目的需要，可是是基本类型，数组，是对象，甚至是immutable.js 生成的数据结构。唯一的点是当state 变化时需要返回全新的对象，而不是修改传入的参数。reducer 要用纯函数。那么什么是纯函数。&lt;/p&gt;
  &lt;h3 id=&quot;纯函数&quot;&gt;纯函数&lt;/h3&gt;
  &lt;p&gt;纯函数 pure function 是这样一种函数，输入输出数据流全是显式的，显式的意思是，函数与外界交换数据只有一个唯一的渠道，参数和返回值。函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过函数返回值传递到该函数外部。
纯函数不能访问外部变量，它能接触的外部参数只有来自外部的参数。纯函数不能修改参数，因为这样做可能会把一些信息通过输入参数夹带到外界。
reducer 就是这样的纯函数，永远不要在reducer 里做一下操作：&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;修改传入的参数&lt;/li&gt;
    &lt;li&gt;执行有副作用的操作，比如：请求API和路由跳转&lt;/li&gt;
    &lt;li&gt;调用非纯函数，如 new Data.now(),Math.random()&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;函数副作用会给应用带来不可预测的麻烦，产生难以预测的效果。严格的函数式语言要求函数必须无副作用。&lt;/p&gt;
&lt;h3 id=&quot;不能修改参数-state&quot;&gt;不能修改参数 state&lt;/h3&gt;
&lt;p&gt;当state 是对象时，修改参数state会影响程序的变更追踪。如果你在项目里使用了react-redux 将redux 程序连接上了UI 组件上，那么你的组件将不能更新，因为react-redux 无法察觉到任何state变化。为什么会发生这样的事情？因为在javascript 上，对象是引用类型，当你改变了参数state 变化前后的state 将会指向同一个内存地址，react-redux 就会以为这是两个相同的state，而不会进行渲染。&lt;/p&gt;
&lt;h2 id=&quot;store&quot;&gt;store&lt;/h2&gt;
&lt;p&gt;store 是个全局对象，将action 和reducer 以及state 联系在一起。Store 有一下职能：
维持应用的state
提供getState 方法获取state
提供dispatch 方法更新state
通过subscribe (listener)注册监听器&lt;/p&gt;

&lt;p&gt;创建store需要从redux 包中导入createStore 这个方法。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import  {createStore} from 'redux'&lt;/code&gt; 
使用reducer 纯函数作为第一个参数创建store
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let store = createStore(reducer)&lt;/code&gt;
还可以添加第二个参数，作为初始化state&lt;/p&gt;
&lt;h3 id=&quot;获取和监听&quot;&gt;获取和监听&lt;/h3&gt;
&lt;p&gt;创建完store 使用它获取数据，并监听变化&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const store = createStore(reducer);
let currentValue = store.getState();
store.subscribe(()=&amp;gt;{
    const previousValue = currentValue;
    currentValue = store.getState();
    console.log(previousValue, currentValue)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上代码做了这样几件事：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;获取初始化state和currentValue&lt;/li&gt;
  &lt;li&gt;使用store.subscribe()方法监听变化&lt;/li&gt;
  &lt;li&gt;在store.subscribe的回调函数中，将currentValue 传递给previousValue 作为先前的state&lt;/li&gt;
  &lt;li&gt;获取更新后的state 到curentValue 作为当前的state&lt;/li&gt;
  &lt;li&gt;打印变化前后的state&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;发起action&quot;&gt;发起action&lt;/h2&gt;
&lt;p&gt;Store 使用dispatch(action)方法发起action，更新state
当发起action后，就将action 穿进了store中，使用reducer 纯函数继续执行更新。改变内部state 唯一方法是dispatch 一个action。这样确保了视图和网络请求都不能直接修改state，相反它们只能表达想要修改state的意图，也就是dispatch 一个action。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;action 是个javascript 对象，包含一个type 字段的javascript 对象，它是store 数据的唯一来源。&lt;/li&gt;
  &lt;li&gt;reducer 是一个纯函数，不要在reducer 中做这些事情，修改传入参数state，执行有副作用的操作，调用非穿函数&lt;/li&gt;
  &lt;li&gt;store 负责更新，查询，订阅state 等多个工作。store 是全局唯一的，它将action，reducer，state联系在一起。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">简书 i蒹葭从风 转载请注明原创出处，谢谢！ 如果读完觉得有收获的话，欢迎点赞加关注</summary></entry><entry><title type="html">微信小程序系列「一」</title><link href="http://localhost:4000/2016/10/27/we-chat-app-pages-1.html" rel="alternate" type="text/html" title="微信小程序系列「一」" /><published>2016-10-27T08:48:45+08:00</published><updated>2016-10-27T08:48:45+08:00</updated><id>http://localhost:4000/2016/10/27/we-chat-app-pages-1</id><content type="html" xml:base="http://localhost:4000/2016/10/27/we-chat-app-pages-1.html">&lt;p&gt;2016年9月21日，在前端届的确是一个值得纪念的日子。这天，微信放出杀手锏，WeChatApp 又称微信小程序。但是就目前来看，有诸多不便，但是这个事情，依然有很大的意义。因为这是一个生态。从放出来这个消息，就开始关注。加上公司也有内测资格，所以准备写一些文章来聊聊weChatApp开发的一些情况，以及踩到的坑。
&lt;!--more--&gt;
首先提到的便是1M的大小限制🚫，其实这个看到1M的大小，觉得没什么，但是作为一个大的公司，那么多业务，总共就1M，那么就比较可怜了。算起来我们BU获得的大小容量就100Kb，100Kb是什么概念，纯代码大概只有3000行左右的代码。但是我们之前的代码压缩之后也有235kb呢。反正容量是一个限制。
其次：很多官方推荐的API也是不能用的。比如ES6，虽然后来开发工具支持了ES6，但是一些android 机是不支持ES6的，也是呵呵哒。还有官方推荐flex布局，但是在iOS 8及其以下是不支持flex布局的，那怎么办呢？官方给的解释是，自己去做兼容。
官方很容易改变API，很多官方组件还没上线呢，就已经废弃了。比如一下的截图：
&lt;img src=&quot;https://raw.githubusercontent.com/iu2fish/_posts/master/media/14779317322951.jpg&quot; alt=&quot;&quot; /&gt;
这个就比较尴尬了。很多在内测的公司，估计第一版就是按着官方的组件来的，结果还没上架，你就把官方的组件给废弃了，这是拿内测公司当小白鼠呢。但是，就算是当小白鼠，很多公司还是跪舔着争当小白鼠。
下面来说说开发中遇到的坑&lt;/p&gt;
&lt;h5 id=&quot;setdata-以数据来驱动view&quot;&gt;setData 以数据来驱动view&lt;/h5&gt;
&lt;p&gt;在第一版的API中，setData是可以在onLoad的时候，设置数据的，但是更新一次api之后，在onload就不能设置setData了，但是官方的文档，并没有提到这个。还有在setData的时候，如果数据，有多层级。当数据有改变的时候，必须从外层开始设置，例如&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obj:{
    innerObj:{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果在setData的时候写法这样的话，是无效的。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.setData({
	innerObj:innerObj
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样是无效的。
还有在上面提到，在onload 的时候设置setData无效，那怎么办呢，就像我们的项目，必须设置的话，只能采取官方不推荐或者说，比较猥琐的解决方案。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.data.obj = obj;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;虽然官方不推荐，但是也没办法不是吗
setData在内部的一个队列方案，这个以后会详细的说，这一篇主要是说说小程序有哪些坑。现在有解决方案的，就把解决方案说一下，没有的话，就是吐槽吧。&lt;/p&gt;
&lt;h4 id=&quot;数据存储&quot;&gt;数据存储&lt;/h4&gt;
&lt;p&gt;每个微信小程序都可以有自己的本地缓存，可以通过 wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。本地缓存最大为10MB。
在第一版的api中，删除storage是不能指定key进行删除的。那么怎么删除指定的storage呢，只有把当前的key的value值设置为空了。&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;wx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setStorage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个确实也够猥琐的，不过后来的更新中，微信提供了，指定key的删除方法。&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;wx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeStorage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;OBJECT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/iu2fish/_posts/master/media/14780057339213.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也提供了，同步删除的方法。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wx.removeStorageSync(KEY)&lt;/code&gt;
用法
&lt;img src=&quot;https://raw.githubusercontent.com/iu2fish/_posts/master/media/14780058000923.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;request请求并发限制&quot;&gt;request请求并发限制&lt;/h4&gt;
&lt;p&gt;微信为了保证安全，在同时request请求的时候，做了限制，也就是同时并发5个请求，这个暂时无解。只能自己去封装队列来处理请求。
request没有cancel的事件，只要这个请求发出去了，是不能取消的。&lt;/p&gt;
&lt;h4 id=&quot;5层url跳转&quot;&gt;5层url跳转&lt;/h4&gt;
&lt;p&gt;微信也是为了安全考虑，限制了，页面跳转的限制，如果层级大于5个的话，不报错，页面就是白页，官方提供的wx.redirectTo去处理，而不是wx.navigateTo。&lt;/p&gt;
&lt;h4 id=&quot;view的布局以及wxss&quot;&gt;view的布局以及wxss&lt;/h4&gt;
&lt;p&gt;官方推荐flex布局，但是当使用form表单的时候，form表单支持flex的并不是很好，使用的时候，要注意。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action-sheet&lt;/code&gt; 这个东西，很适合做下面的筛选项，但是这个适合少量的数据，因为不能滚动而且自带的样式也是不好控制。呵呵哒。不过也被官方判了死刑，还未上线就被废弃。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modal lodding toast&lt;/code&gt;，这3个组件已经被官方判了死刑了，还没上线就被废弃。&lt;/p&gt;
&lt;h4 id=&quot;wxss的一些限制&quot;&gt;wxss的一些限制&lt;/h4&gt;
&lt;p&gt;第一版的时候，wxss不支持层级选择，后来更新的时候，官方把这句话给删除了，也不知道是推荐使用层级还是不支持，反正就是把不支持层级选择给删除了。官方的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;changelist&lt;/code&gt;也没提到这块。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iconfont&lt;/code&gt;能不能使用？可以，但是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ios&lt;/code&gt;下有兼容性，如果使用在线的iconfont的话，ios不支持，所以为了包的容量，只能&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base64&lt;/code&gt;在本地了。&lt;/p&gt;

&lt;h4 id=&quot;另外一些别的坑如业务交互&quot;&gt;另外一些别的坑，如业务交互&lt;/h4&gt;
&lt;p&gt;这块等下一篇再详细介绍&lt;/p&gt;</content><author><name></name></author><category term="WeChatApp" /><category term="javascript" /><category term="react" /><summary type="html">2016年9月21日，在前端届的确是一个值得纪念的日子。这天，微信放出杀手锏，WeChatApp 又称微信小程序。但是就目前来看，有诸多不便，但是这个事情，依然有很大的意义。因为这是一个生态。从放出来这个消息，就开始关注。加上公司也有内测资格，所以准备写一些文章来聊聊weChatApp开发的一些情况，以及踩到的坑。 首先提到的便是1M的大小限制🚫，其实这个看到1M的大小，觉得没什么，但是作为一个大的公司，那么多业务，总共就1M，那么就比较可怜了。算起来我们BU获得的大小容量就100Kb，100Kb是什么概念，纯代码大概只有3000行左右的代码。但是我们之前的代码压缩之后也有235kb呢。反正容量是一个限制。 其次：很多官方推荐的API也是不能用的。比如ES6，虽然后来开发工具支持了ES6，但是一些android 机是不支持ES6的，也是呵呵哒。还有官方推荐flex布局，但是在iOS 8及其以下是不支持flex布局的，那怎么办呢？官方给的解释是，自己去做兼容。 官方很容易改变API，很多官方组件还没上线呢，就已经废弃了。比如一下的截图： 这个就比较尴尬了。很多在内测的公司，估计第一版就是按着官方的组件来的，结果还没上架，你就把官方的组件给废弃了，这是拿内测公司当小白鼠呢。但是，就算是当小白鼠，很多公司还是跪舔着争当小白鼠。 下面来说说开发中遇到的坑 setData 以数据来驱动view 在第一版的API中，setData是可以在onLoad的时候，设置数据的，但是更新一次api之后，在onload就不能设置setData了，但是官方的文档，并没有提到这个。还有在setData的时候，如果数据，有多层级。当数据有改变的时候，必须从外层开始设置，例如 obj:{ innerObj:{} } 如果在setData的时候写法这样的话，是无效的。 this.setData({ innerObj:innerObj }) 这样是无效的。 还有在上面提到，在onload 的时候设置setData无效，那怎么办呢，就像我们的项目，必须设置的话，只能采取官方不推荐或者说，比较猥琐的解决方案。 this.data.obj = obj; 虽然官方不推荐，但是也没办法不是吗 setData在内部的一个队列方案，这个以后会详细的说，这一篇主要是说说小程序有哪些坑。现在有解决方案的，就把解决方案说一下，没有的话，就是吐槽吧。 数据存储 每个微信小程序都可以有自己的本地缓存，可以通过 wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。本地缓存最大为10MB。 在第一版的api中，删除storage是不能指定key进行删除的。那么怎么删除指定的storage呢，只有把当前的key的value值设置为空了。 wx.setStorage({ key:&quot;key&quot;, data:&quot;&quot; }) 这个确实也够猥琐的，不过后来的更新中，微信提供了，指定key的删除方法。 wx.removeStorage(OBJECT)</summary></entry><entry><title type="html">eslint 在项目中的使用</title><link href="http://localhost:4000/2016/09/27/eslint-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.html" rel="alternate" type="text/html" title="eslint 在项目中的使用" /><published>2016-09-27T09:04:33+08:00</published><updated>2016-09-27T09:04:33+08:00</updated><id>http://localhost:4000/2016/09/27/eslint-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8</id><content type="html" xml:base="http://localhost:4000/2016/09/27/eslint-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.html">&lt;p&gt;前段一段时间，组里搞了jslint，但是，jslint好像没有eslint的配置灵活一些，并且webstrom 也支持eslint，所以就自己搞了一套eslint的检测配置，虽然提交了代码，但是并不强制要求使用。&lt;/p&gt;

&lt;!--more--&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
***
***
Rules 规则说明
'off' 或者 0  - 关闭规则
'warn' 或者 1 - 开启规则，使用警告级别的错误，warn 不会导致程序退出
'error' 或者 2 - 开启规则，使用错误级别的错误，error 当被触发的时候，程序会退出

 @link http://eslint.cn/docs/rules/
 @link http://eslint.org/docs/rules/
*/


{
  &quot;env&quot;: {
    &quot;browser&quot;: false,
    &quot;node&quot;:true,
    &quot;es6&quot;: true
  },
  &quot;globals&quot;: {

  },
  &quot;rules&quot;: {
    &quot;camelcase&quot;: 2,
    &quot;curly&quot;: 0,
    &quot;brace-style&quot;: [2, &quot;1tbs&quot;],
    &quot;quotes&quot;: [2, &quot;single&quot;],
    &quot;semi&quot;: [2, &quot;always&quot;],
    &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],

    &quot;space-infix-ops&quot;: 2,

    &quot;no-unused-vars&quot;: [&quot;error&quot;, { &quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;all&quot; }],

    &quot;comma-dangle&quot;: [2, &quot;only-multiline&quot;],
    &quot;no-cond-assign&quot;: 2,
    &quot;no-console&quot;: 2,
    &quot;no-constant-condition&quot;: 0, // 待确定
    &quot;no-control-regex&quot;: 0,
    &quot;no-debugger&quot;: 2,
    &quot;no-dupe-args&quot;: 2,
    &quot;no-dupe-keys&quot;: 2,
    &quot;no-duplicate-case&quot;: 2,
    &quot;no-empty&quot;: 2,
    &quot;no-empty-character-class&quot;: 2,
    &quot;no-ex-assign&quot;: 2,
    &quot;no-extra-boolean-cast&quot;: 2,
    &quot;no-extra-semi&quot;: 2,
    &quot;no-func-assign&quot;: 2,
    &quot;no-inner-declarations&quot;: 2,
    &quot;no-prototype-builtins&quot;: 2,
    &quot;use-isnan&quot;: 2,
    &quot;valid-jsdoc&quot;: 2,
    &quot;valid-typeof&quot;: 2,
    &quot;accessor-pairs&quot;: 2,
    &quot;array-callback-return&quot;: 2,
    &quot;block-scoped-var&quot;: 2, // Fix me 是否有必要开启
    &quot;complexity&quot;: [2, {'max': 4}],
    &quot;consistent-return&quot;: 0,
    &quot;default-case&quot;: 2,
    &quot;dot-location&quot;: [2, &quot;property&quot;],
    &quot;eqeqeq&quot;: 2,
    &quot;guard-for-in&quot;: 2, //  不建议使用for in 循环
    &quot;no-alert&quot;: 2,
    &quot;no-case-declarations&quot;: 2,
    &quot;no-else-return&quot;: 0,
    &quot;no-empty-function&quot;: 2,
    &quot;no-eq-null&quot;: 2,
    &quot;no-eval&quot;: 2,
    &quot;no-extend-native&quot;: 2,
    &quot;no-extra-bind&quot;: 2,
    &quot;no-fallthrough&quot;: 2,
    &quot;no-floating-decimal&quot;: 2,
    &quot;no-implicit-coercion&quot;: 0,
    &quot;no-implicit-globals&quot;: 2,
    &quot;no-implied-eval&quot;: 2,
    &quot;no-invalid-this&quot;: 0,
    &quot;no-lone-blocks&quot;: 2,
    &quot;no-loop-func&quot;: 2,
    &quot;no-magic-numbers&quot;: 2,
    &quot;no-multi-spaces&quot;: 2,
    &quot;no-multi-str&quot;: 2,
    &quot;no-native-reassign&quot;: 2,
    &quot;no-new&quot;: 2,
    &quot;no-new-func&quot;: 2,
    &quot;no-new-wrappers&quot;: 2,
    &quot;no-octal&quot;: 2,
    &quot;no-octal-escape&quot;: 2,
    &quot;no-param-reassign&quot;: [2, { &quot;props&quot;: false }],
    &quot;no-redeclare&quot;: 2,
    &quot;no-return-assign&quot;: 2,
    &quot;no-script-url&quot;: 2,
    &quot;no-self-assign&quot;: 2,
    &quot;no-self-compare&quot;: 2,
    &quot;no-useless-call&quot;: 2,
    &quot;wrap-iife&quot;: 2,
    &quot;block-spacing&quot;: 0,
    &quot;indent&quot;: [2, &quot;tab&quot;]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">前段一段时间，组里搞了jslint，但是，jslint好像没有eslint的配置灵活一些，并且webstrom 也支持eslint，所以就自己搞了一套eslint的检测配置，虽然提交了代码，但是并不强制要求使用。</summary></entry><entry><title type="html">团队JavaScript的一些规范</title><link href="http://localhost:4000/2016/08/22/%E5%9B%A2%E9%98%9FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83.html" rel="alternate" type="text/html" title="团队JavaScript的一些规范" /><published>2016-08-22T06:31:29+08:00</published><updated>2016-08-22T06:31:29+08:00</updated><id>http://localhost:4000/2016/08/22/%E5%9B%A2%E9%98%9FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83</id><content type="html" xml:base="http://localhost:4000/2016/08/22/%E5%9B%A2%E9%98%9FJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83.html">&lt;h3 id=&quot;命名规范&quot;&gt;命名规范&lt;/h3&gt;
&lt;h4 id=&quot;全名总体规范&quot;&gt;全名总体规范&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;尽量以英文名命名，避免出现拼写错误&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; //restful返回字段fistchar拼写错误
  var firstChar = city.fistchar.toUpperCase();
  //框架写错
  model.excute(...)
  //单词拼写不规范
  detailinfo.rainfos = pts.modeldata.boxs[0].rainfos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;除非特殊情况，如约定，不得以拼音方式命名（包括注释）&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //周边
  zbAction: function (e) {...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;
&lt;ol&gt;
  &lt;li&gt;同一含义的命名，统一用一种英文单词，如gologin, gosign, 并且前后端命名一致&lt;/li&gt;
&lt;/ol&gt;

 	```
 	//是否登录
 	isLogin: function () {…
 	//去登录
&lt;p&gt;goSignin: function (e) {…&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
4. 尽量不要缩写，非要缩写，英文缩写按音节，并以辅音结尾
	[查看百度文库缩写](http://wenku.baidu.com/link?url=ml6os4CXN0DqPnwI5DWtMlzldz6dGqpoTa_G8lADWUBWyCoMwgFM23uNrrm1ygCSs1zbbacYN9vOuNcgOzG_VOLJuJRALpzy015QKL2xlqu)
5. 命名必须望文生意，可读性强

	```
	//好
	 getBoxResById: function (id) {
	//不好
	getRes:function(boxid){

	```

6. 禁止使用单字符命名

	```
	var p = this.getPassengerById(id);
	function a(){...};
	```

#### 文件及文件夹命名
1. 全部小写文件名.扩展名

	```
		citylist.js//注意文件名全小写，避免linux和window不同系统开发时，大小写敏感不一致问题
	```

2. 以.号分割，不得以_等其它分割符

	```
	//约定不要这样写
	require_config.js
	//推荐都用.分割
	require.config.js或者requireconfig.js
	```

4. 同一功能职责集的文件，拆分后，以相同前缀开始，如index.\*.js, booking.\*.js

	```
	index.js
	index.search.js //表示对index.js的功能扩展搜索功能
	index.siderbar.js//表示对index.js的功能扩展边栏功能
	```

#### 变量（包括实例变量）

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;//采用驼峰命名法
var ticketService = TicketService.getInstance();&lt;/p&gt;

&lt;p&gt;//私有变量可以_开头，但尽量少用
var _index = $(e.currentTarget).index() + 1;&lt;/p&gt;

&lt;p&gt;//通过选择器获取的dom节点引用，可以用$开头
var $bookingContainer = this.$el.find(…);&lt;/p&gt;

&lt;p&gt;//多个变量声明时，推荐采用单var模式声明变量
var foo = 1,//多个变量竖向排列
	bar = 2,//推荐=号对齐
	coo;//未初始化的放在最后&lt;/p&gt;

&lt;p&gt;//变量最好不要用动词开头
var getTicketCount = 2; //不好的写法&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#### 方法
驼峰命名

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;点击当地玩乐右边几个标签&lt;/li&gt;
  &lt;li&gt;@param e&lt;/li&gt;
  &lt;li&gt;@author jianjia.de
*/
activityCategoryAction: function (e) {
```&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;布尔型getter 以is等开头如isLogin()&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; isLogin: function () {
            return islogin;
        },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其它getter 以get开头，如getSelectedCity()&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; getSpotId: function () {
            return spotid;
        },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;setter 以set开头，如setLogin()&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setLogin: function (value) {
            islogin = value;
        },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;private或protected方法可以用_开头，表示外部禁调用_开头的方法&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getPassengerCount: function (ticketId) {
  ...//此处省略N行
  return this._getPassengerCount();
},
_getPassengerCount: function (ticketId) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;public方法不得以_开头，并且必须有多行注释&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 获取票张数
* @param ticketId {number}
* @returns {*}
*/
getTicketCount: function (ticketId) {
  ...//此处省略N行
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法参数不得超过4个，否则要柯理化&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//不好，参数太长了
function foo(arg1, arg2, arg3, arg4, arg5...){

//柯理化
function foo(options){
	var arg1 = options.arg1,
		arg2 = options.arg2,
		...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法名最好用动词或以动词开头命名&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取pageid
pageid: function (hash) {//不推荐写法，应该用getPageId
  var pageids = pageId.pageid;
  return pageids[hash] ? pageids[hash][0] : &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法名不要缩写&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getTid(){...}//不好
function getTicketId(){}//推荐
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;常量&quot;&gt;常量&lt;/h4&gt;
&lt;p&gt;全部大写，并以_号分割如&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var MANUAL_SWITCH_TIP = '定位不到当前城市，可手动切换',
     MANUAL_ENABLE_GEO = '定位未开启&amp;lt;br /&amp;gt;请到手机设置中开启定位服务';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字符常量， 如模拟枚举等，值与常量名一样&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define({
    //订单页消息常量
    BOOKING_NOTIFICATION: {
        BOOKING_LOGIN_INFO_READY: 'BOOKING_LOGIN_INFO_READY',
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;类名&quot;&gt;类名&lt;/h4&gt;
&lt;p&gt;类名以大驼峰（帕斯卡）命名法，即以大写开头的驼峰命名法
 实例名小驼峰全名法，（单例）与类名一致&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var TicketCityService = require('TicketCityService');
var ticketCityService = TicketCityService.getInstance();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;代码格式规范&quot;&gt;代码格式规范&lt;/h3&gt;
&lt;h4 id=&quot;注释&quot;&gt;注释&lt;/h4&gt;
&lt;p&gt;单行注释 // 注释内容（注意注释内容行首//后有个空格）
多行注释（注意注释内容行首*后有个空格）
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;注释内容
 */&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;注释保持简洁，可读性强，不要冗余&lt;/li&gt;
  &lt;li&gt;单行注释过长也可另起一行&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块文件， 必须包含@description,@author,可选@version,@createDate&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
   * @description 订单填写
   * @author jianjia.de
   */
  define(function (require) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法注释, 必须包含@description,@param，可选@return,@deprecated&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
  * 渲染推荐门票数据
  * @param data 门票返回数据
  * @param city
  * @deprecated
  */
  renderRecommendTicket: function (data, city) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;public方法必须有且用多行注释，private/protected方法可用单行注释&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //根据门票资源id, 获取这张票要填写几个出行人
  _getPassengerCount: function (ticketId) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;model注释，必须包括@description,@author,@version&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
  * @description:  首页精选门票
  * @author:       jianjia.de
  * @version 6.18
  */
  TicketRecommendProductListModelV1: {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如有链接请加上@link或@see&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //@link http://conf.exmaple.com
 var AdSlider = require('AdSlider'),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;代码中注释，没必要留着的，要定期清理，除非某些需求必须先放着，以防产品变更&lt;/li&gt;
  &lt;li&gt;方法内一律使用单行注释，当需要多行时，可用单行叠加&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待优化或修复的代码前加//TODO和//FIXME注释, 一般编辑器都会有提示&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   for (var i = 0, len = cities.length; i &amp;lt; len; i++) {
  //Fixme jianjia.de 6.19验证一下，删除以下无用数据
  ...

  &amp;lt;!--使用方法。TODO:@weiyh.6.20写到js里去,这模板太繁杂了。--&amp;gt;
&amp;lt;%var useage = _.find(ticket.rainfos || [], function(item) {
      return item.subtcode == '13' &amp;amp;&amp;amp; _.size(item.desclist);
  }), qkdesc = '';

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试用的一些注释，别提交上来&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;////////////test commit

  return TicketStore;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;引号&quot;&gt;引号&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;字符串统一用单引号，html片断统一用双引号&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  url: 'RecommendProductListV1QOC',
  var tpl='\&amp;lt;div class=&quot;xxx&quot;\&amp;gt;{...}\&amp;lt;/div\&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;json对象的key如果不是关键字，统一不用加引号&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var config = { buEvn : 'dev'}//buEvn没必要加此号，dev加单引号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;在网上也有很多争论，大家可以参考道格拉斯大神的说法，双引号看起来很脏，而且要多敲一下shift;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;数字&quot;&gt;数字&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var count = 100;//整数
var price = 100.5;//小数
var price = 100.; //禁止省略小数
或var price=.5//禁止省略整数
var count = 0xf5;//可以用十六进制
var count = 4e23;//可以用科学计数
var count = 010;//禁止使用八进制写法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;对象直接量&quot;&gt;对象直接量&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//不好的写法
var obj = new Object();
obj.a =1; obj.b=2; obj.c=3;
//google和crockford推荐写法
var obj = {a:1, b:2, c:3};
//或者已有对obj时，用
_.extend(obj, {a:1,b:2,c:3};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;缩进&quot;&gt;缩进&lt;/h4&gt;
&lt;p&gt;统一以4个空格缩进排版，请应用.editconfig配置&lt;/p&gt;

&lt;h4 id=&quot;空格&quot;&gt;空格&lt;/h4&gt;
&lt;p&gt;这说来话长长长，请应用webstorm默认配置，比如=号两边空格。
参考门票项目views/index.js为范本&lt;/p&gt;

&lt;h4 id=&quot;句末不要偷懒省略分号&quot;&gt;句末不要偷懒省略分号&lt;/h4&gt;
&lt;p&gt;在某些情况下，会出错或未按预期效果执行，如&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var foo = abc//后面没加分号，导致压缩执行错误
(function(){})();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function abc(){
	return
	{a:1};//两个错1.return后没加;号2.{另起一行
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;左号不得另起一行&quot;&gt;左{号不得另起一行&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;这里是有争论，但是google等公司都明禁止此行为，说来也话长，大家先遵守了&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;对象最后一行以结束&quot;&gt;对象最后一行以“,”结束&lt;/h4&gt;
&lt;p&gt;这点不强要求，但用React的童鞋必须加，但这已经是ES6规范，避免在新增时，版本控制多一条记录&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var config = {
	key1:111,
	key2:222,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;单行长度&quot;&gt;单行长度&lt;/h4&gt;

&lt;p&gt;一般以笔记本全屏最长不需横向滚屏值为最大容忍值，这里估且约定为150，以不超过100行为最佳
&lt;em&gt;编辑器可以配置&lt;/em&gt;
&lt;em&gt;横向滚屏对于纯键盘操作，简直是噩耗，而且代码一个长横条也很不美观&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;单文件行数&quot;&gt;单文件行数&lt;/h4&gt;
&lt;p&gt;单个文件，最长行数约定最长容忍行数是1500行， 以不超过1000行最佳。
&lt;em&gt;编辑器可以配置&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;对齐&quot;&gt;对齐&lt;/h4&gt;
&lt;p&gt;一般js编辑器都会自动对齐和缩进，比如花括号对齐，然而有些模板文件，因为解析不好，需要手工对齐&lt;/p&gt;

&lt;p&gt;还有很多，不穷举了, 用vi的某些少年，注意对齐&lt;/p&gt;

&lt;h4 id=&quot;块嵌套&quot;&gt;块嵌套&lt;/h4&gt;
&lt;p&gt;块嵌套不宜过深，约定不得超过4层，以不超过3层最佳&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//过多的枪套会让代码呈现麻花状，可读性变差
if(a){
	if(b){
		if(c){
			if(d){
				}
			}
	}
}
//可能改造写法如下
if(!a) return;//能return则return
if(!b) return;
if(c){
	if(d){
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;空行&quot;&gt;空行&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方法之间加空行&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
  * 身份证后的X全部转成大写
  */
  replaceX: function () {
  ...
  },

  /**
  * 获取出行人数量
  * @param ticketId {number}
  * @returns {number}
  */
  getPassengerCount: function (ticketId) {
    ...
  },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法内，代码逻辑相对独立的行，用空行隔开&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
  * 精选推荐最后,点击查看{cityname}全部{total}条产品事件处理
  */
  moreRecommendAction: function (e) {
    e.preventDefault();
    var data = this.recommendData;
    if (!data) return;

    var _cityInfo = this.getSelectedCity();
    this.traceLog.log(Ubt.UBT_URL.INDEX.INDEX_MORE_RECOMMEND, {
        hash: 'index',
        cityid: _cityInfo.id
    }, Ubt.UBT_KEY.HOME);

    if (data.mcount === 0 &amp;amp;&amp;amp; data.total &amp;gt; 10) {//直接查看cityname全部产品
        this.listAction(1);
        return;
    }

    if (data.isosea) {//国外：查看{国家}全部产品                
        ...
    } else if (data.total) {//国内：城市及周边
       ...            
    } else {//国内：城市周边
       ...
    }
  },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;变量/常量归类var时，也用空行隔开&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var Guider = require('cGuider'),

  var rightMenu = TicketConfig.h5.indexMenu, //首页右侧菜单
     	 leftBack  = TicketConfig.h5.indexBack; //首页后退是否禁止

  var MANUAL_SWITCH_TIP = '定位不到当前城市，可手动切换',
 		MANUAL_ENABLE_GEO = '定位未开启&amp;lt;br /&amp;gt;请到手机设置中开启定位服务';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常见写法规范&quot;&gt;常见写法规范&lt;/h3&gt;
&lt;h4 id=&quot;事件&quot;&gt;事件&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;尽量采用委托方式注册事件（都懂的）&lt;/li&gt;
  &lt;li&gt;事件处理时e.preventDefault()一下，以防止如默认跳转。&lt;/li&gt;
  &lt;li&gt;事件尽量注册在自定义的class或id下，而不是csser提供的样式名，以防样式变更引起bug&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;events: {
  &quot;click .tkt-pop-container ul li&quot;: &quot;loginTab&quot;,//不好，UI调整时，样式有可能会变
  &quot;click .gomorecalendar&quot;: &quot;goCalendar&quot;,//不好，自定义class与csser应用的class混杂
  &quot;click #ticket-booking-moretickets&quot;: &quot;goMoreTickets&quot;,//可以,但不推荐因为id是唯一的
  'click .js_checkInsu': 'checkInsu', //好，推荐
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;事件回调函数统一用*action， 如果是序列节点，则以itemAction结尾&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 精选特价点击处理
* @param e
*/
recommendItemAction: function (e) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;相同/嵌套的节点，避免以不同的选择器，重复注册为不同的回调
  &lt;em&gt;现场演示更换优惠券代码&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;amdcmd写法&quot;&gt;amd/cmd写法&lt;/h4&gt;
&lt;p&gt;同一模块编写时，amd, cmd写法，只能用一种，否则打包后，在某些webview下会报错&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//不行
+ define(['a'],function(a){ var b=require('b');...});//混着写H5ok,但是...呵
//可行
define(['a','b'],function(a,b){...});
define(function(require){var a=require('a'),b=require('b')});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;条件循环语句中不要有赋值操作&quot;&gt;条件/循环语句中不要有赋值操作&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(a=b){...}
while(el=...){...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;条件循环语句后跟&quot;&gt;条件/循环语句后跟”{“&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 不好的写法
if(con)
	doSomething();
// 可以容忍的写法
if(con) doSomething();
// 推荐的写法1
if(con) {
	doSomething();
}
// 推荐写法2
con &amp;amp;&amp;amp; doSomething();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;其它for, while, do..while, try..catch..finally同理&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;尽量使用原生新方法es5而不是框架的方法&quot;&gt;尽量使用原生新方法(es5)，而不是框架的方法&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [1,2,100,3,20,9];
找出item&amp;gt;10的集合
//不推荐的写法
for(var i=0, tmp=[];i&amp;lt;arr.length;i++){
	if(arr[i]&amp;gt;10){
		tmp.push(arr[i]);
	}
}
// 推荐写法1
var tmp = arr.filter(function(item){return item&amp;gt;10});

// 推荐写法2
// 在不确定arr是否有值，并且是数组的情况下，可使用如下，但尽量用推荐1，效率高一些
var tmp = _.filter(arr,function(item){return item&amp;gt;10});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;其它find, some, every等es5新增的api都用起来&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;禁止使用eval和with&quot;&gt;禁止使用eval和with&lt;/h4&gt;
&lt;p&gt;效率太差，underscore模板引擎就有这货，干死&lt;/p&gt;

&lt;h4 id=&quot;尽量少用trycatch&quot;&gt;尽量少用try..catch&lt;/h4&gt;
&lt;p&gt;除非特殊情况，能不用try解决，尽量不要用，加了这货性能就变差了&lt;/p&gt;

&lt;h4 id=&quot;禁止放空异常&quot;&gt;禁止放空异常&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try{
	doSomething()
}catch(ex){
	//nocode here
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;使用三等而不是双等&quot;&gt;使用三等而不是双等&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//举个小例子（被坑死的案例还有很多）
null==undefined;//true
new Object(1)==1;//true;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;选择器&quot;&gt;选择器&lt;/h4&gt;
&lt;p&gt;尽量减少对dom节点的遍历，已选择过的节点，尽量在模块create/show的时候保存引用&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//不好
var a = this.$el.find(x a);
var b = this.$el.find(x b);
var b2 = this.$el.find(x b);

//应该
var x = this.$el.find(a),
a=x.find(a),
b=x.find(b),
b2=b;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;全局全变&quot;&gt;全局全变&lt;/h4&gt;
&lt;p&gt;目前只允许ticket单全局变量，除非是框架已经挂好，如network
&lt;strong&gt;污染全局变量，初学者容易范的错，老鸟有时也会阴沟翻床，可以用辅助工具检查&lt;/strong&gt;
&lt;strong&gt;有些JS框架会采用命名空间的形式，来管理单全局变量，但我们项目约定不使用&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var myvar = 1;
myvar =2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;及时清除记时器&quot;&gt;及时清除记时器&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setTimeout(function () {
    self.getGeoInfo(self.getGeoInfoOk, self.getGeoInfoError);
}, 300);

var tid = setTimeout(function () {
    self.getGeoInfo(self.getGeoInfoOk, self.getGeoInfoError);
    clearTimeout(tid);
}, 300);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;不要在原生原生方法或框架级别的方法的原型链上加东西&quot;&gt;不要在原生原生方法，或框架级别的方法的原型链上加东西&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;建议把getURLParams写到项目的util里
AbstractStore.prototype.getURLParams = function () {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;配置抽离&quot;&gt;配置抽离&lt;/h4&gt;

&lt;p&gt;一些常用的配置，请统一写到一个地方&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var config = {
   logServerIP: '',//日志服务器IP
   logServerPort: '',//日志服务器端口
   logAble: false,//是否允许向服务端发送日志
   consoleAble: true,//是否允许向原生控制台打日志
   guiderPrintAble: false,//是否允许向facade打印日志
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;js和模板尽量分离&quot;&gt;js和模板尽量分离&lt;/h4&gt;

&lt;p&gt;参考6.19的门票优惠券代码改造前，与改造后代码
模板只负责渲染,不要有过多的职责
模板文件过长，有相对逻辑独立的模块进行拆分
js文件尽量提示给模板渲染所需的所有字段，哪怕是组装出来的&lt;/p&gt;

&lt;p&gt;&lt;em&gt;以下是出行人列表一段不要的模板代码&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;% if(!!template&amp;amp;&amp;amp;tickets.length==1){ %&amp;gt;

   &amp;lt;% var firstpassenger = passengers[0] || {};
       var ele;
       var language = 0;
       var viewlanguage = 0;
       if (!!template.name &amp;amp;&amp;amp; !template.ename ){
           language = 1;
           viewlangusge = 1;
       }
       if (!!template.ename &amp;amp;&amp;amp; !template.name){
           language = 2;
           viewlangusge = 2;
       }
       if (!!template.ename &amp;amp;&amp;amp; !!template.name ){
           if(template.ename == template.name){
               language = 3;
           }else{
               language = 4;
           }
           viewlanguage = !!firstpassenger.ename &amp;amp;&amp;amp; !firstpassenger.name ? 2 : 1;
       }
   %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;以下推荐的js为模板准备的全部数据&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.controldata.islogin = this.isLogin();
this.controldata.slide = this.isSlide();
this.controldata.showdetail = this.isShowDetail();//TODO 6.19 是否自动展开详情
this.controldata.isusecoupon = memcacheBooking.isusecoupon;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;避免重复代码&quot;&gt;避免重复代码&lt;/h4&gt;
&lt;p&gt;相同的代码，请不要copy过来用，即时是临时方案，也要记得重构, 写上todo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;events: {
	returnHandler: function () {
	 Guider.apply({
	     hybridCallback: function () {
	         Guider.home();
	     },
	     callback: function () {
	         self.jump('/html5/');
	     }
	 });
	 return true;
	},
	homeHandler: function () {
	 Guider.apply({
	     hybridCallback: function () {
	         Guider.home();
	     },
	     callback: function () {
	         self.jump('/html5/');
	     }
	 });
	 return true;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;巧用语法&quot;&gt;巧用语法&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//有点长
if (typeof json[key] === 'undefined' || json[key] === null) {
    ...
}
//简洁写法
if (!!json&amp;amp;&amp;amp;json[key]) {
    ...
}

//if写法
if(a){doSomething()};
//&amp;amp;&amp;amp;写法
a&amp;amp;&amp;amp;soSomething();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;感谢组里的同事一起合作写的，未完，还待补充。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">命名规范 全名总体规范 尽量以英文名命名，避免出现拼写错误</summary></entry><entry><title type="html">talk about sesionStorage VS localStorage</title><link href="http://localhost:4000/2016/07/12/talk-about-sesionStorage-VS-localStorage.html" rel="alternate" type="text/html" title="talk about sesionStorage VS localStorage" /><published>2016-07-12T07:35:53+08:00</published><updated>2016-07-12T07:35:53+08:00</updated><id>http://localhost:4000/2016/07/12/talk-about-sesionStorage-VS-localStorage</id><content type="html" xml:base="http://localhost:4000/2016/07/12/talk-about-sesionStorage-VS-localStorage.html">&lt;p&gt;最近业务上，有个需求，当一次回话结束，保存的信息，就要销毁。这个一看，正好是sessionStorage的用法，但是之前并没有了解锅sessionStorage，一直是使用localStorage，并且公司的框架封装好了localStorage的用法，所以，趁此机会了解一下sessionStorage的一些API。&lt;!--more--&gt;
说起localStorage和sessionStorage，总要说起我们的小甜饼，Cookie。顾名思义，cookie确实非常小，它的大小只有4K左右，是网景公司的前雇员Lou Montulli在1993年3月的发明。它主要用途是用来存放保存登录信息，比如你登录某个网站是可以看到『记住密码』，这通常就是通过在Cookie中存入一段辨别用户的数据来实现的。&lt;/p&gt;

&lt;h3 id=&quot;localstorage-vs-sessionstorage&quot;&gt;localStorage vs sessionStorage&lt;/h3&gt;
&lt;p&gt;localStorage 是html5 标准中新加入的技术，它并不是什么划时代的新东西。早在IE6的时代，就有一个userDate的东西用于本地存储，而当时考虑到浏览器的兼容性，更通用的方案是使用flash，而如今localStorage被大多数浏览器支持，更多的webview支持，尤其是移动端发展很快。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;Chrome&lt;/th&gt;
      &lt;th&gt;Firefox&lt;/th&gt;
      &lt;th&gt;IE&lt;/th&gt;
      &lt;th&gt;Opera&lt;/th&gt;
      &lt;th&gt;Safari&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;localStorage&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3.5&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;10.50&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sessionStorage&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;10.50&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;sessionStorage 与localStorage 的接口类似，但保存数据的生命周期与localStorage不同。session对于服务端的童鞋，应该比较了解，但是sessionStorage是个前端的概念。可以将一部分信息存在sessionStorage里，在这次回话结束，页面关闭，sessionStorage中的数据就会被清空。
localStorage则不同，它是持久化的，换句话说，如果不这是过期时间，localStorage是不会清空的，前提是，不要手动去清除。而sessionStorage则不是这样，页面关闭，会话结束，保存在sessionStorage的信息就会被清除。
除了这个不同，其他的操作API其实都是一样的，无论是sessionStorage还是localStorage，都有setItem，getItem，clear，removeItem这几个API，具体的见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage&quot;&gt;mdn官方的文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;常用的api&quot;&gt;常用的API&lt;/h3&gt;

&lt;h4 id=&quot;setitem&quot;&gt;setItem&lt;/h4&gt;

&lt;p&gt;setItem支持k-v这种存值，但是v只能是字符串，所以在存之前，必须要JSON.stringify一下呢。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.setItem('TEST','value');

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;getitem&quot;&gt;getItem&lt;/h4&gt;

&lt;p&gt;getItem就比较简单了，只需要localStorage.getItem就可以了，例如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.getItem('TESTR');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;removeitem&quot;&gt;removeItem&lt;/h4&gt;

&lt;p&gt;removeItem这个就是移除某个键值的localStorage&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.removeItem('TEST');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;clear&quot;&gt;clear&lt;/h4&gt;

&lt;p&gt;clear 这个方法很常用，也很直接，就是直接清空缓存&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.clear();

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这就是localStorage最常见的几个API了，不过也是最底层的，但是一般公司不会直接这有去操作localStorage的，因为这个太野蛮了，一点都没封装，比如，直接使用setItem的话，是没设置过期时间的，前面也说到，localStorage的大小有5M左右，但是如果localStorage存放满了，过大了，这时候，用户继续存localStorage的话，怎么办？官方mdn文档没有说，但是也有小伙伴也过一篇文章&lt;a href=&quot;http://crocodillon.com/blog/always-catch-localstorage-security-and-quota-exceeded-errors&quot;&gt;Always catch LocalStorage security and quota exceeded errors&lt;/a&gt;，提到了，如何判断是否存满了&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function isQuotaExceeded(e) {
  var quotaExceeded = false;
  if (e) {
    if (e.code) {
      switch (e.code) {
        case 22:
          quotaExceeded = true;
          break;
        case 1014:
          // Firefox
          if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
            quotaExceeded = true;
          }
          break;
      }
    } else if (e.number === -2147024882) {
      // Internet Explorer 8
      quotaExceeded = true;
    }
  }
  return quotaExceeded;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除了这些，还有一些特别的判断，还是要自己封装好一些自己常用的API，这有使用起来也不至于那么野蛮粗暴，接下来，等这个项目结束后，我会把封装一些常用的API，放在github上，目前项目提测了，等修完bug，就会来填这个坑。
期待吧~&lt;/p&gt;</content><author><name></name></author><category term="JavaScript" /><category term="前端" /><summary type="html">最近业务上，有个需求，当一次回话结束，保存的信息，就要销毁。这个一看，正好是sessionStorage的用法，但是之前并没有了解锅sessionStorage，一直是使用localStorage，并且公司的框架封装好了localStorage的用法，所以，趁此机会了解一下sessionStorage的一些API。 说起localStorage和sessionStorage，总要说起我们的小甜饼，Cookie。顾名思义，cookie确实非常小，它的大小只有4K左右，是网景公司的前雇员Lou Montulli在1993年3月的发明。它主要用途是用来存放保存登录信息，比如你登录某个网站是可以看到『记住密码』，这通常就是通过在Cookie中存入一段辨别用户的数据来实现的。</summary></entry></feed>